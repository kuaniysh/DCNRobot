*** Settings ***
Documentation     控制Station的关键字集合，使用规范：
...
...               ---
...               1. *打开/关闭ssh connection:*
...               - 通过ssh登陆terminal，控制station
...               - 在直接包含test case的test suite内通过关键字Open SSH Connection连接，一般放在setup内
...               - *注意: 在执行Open SSH Connection的test suite结束时，需要关闭cosole，在teardown里使用Close SSH Connection*
...               - *注意: 需要在每个直接包含测试例的test suite内使用Open SSH Connection，teardown里使用Close SSH Connection*
...               - 测试模块初始化的过程，如果需要控制station，需要在初始化关键字的开始使用Open SSH Connection，在初始化关键字的结束时关闭Close SSH Connection，一般初始化关键字在最高层test suite的setup中
...               - 测试模块清理配置的过程，如果需要控制station，需要在清理配置的关键字的开始使用Open SSH Connection，在清理配置的关键字的结束时关闭Close SSH Connection，一般清理配置的关键字在最高层test suite的teardown中
...
...               ---
...               2. *执行命令,获取结果*
...               - 执行命令的关键字有：Execute Command；Start Command，Read Command Output；Write，Read Until Prompt等
...               - Execute Command一般用于非交互式的命令（每个Execute Command都会打开一个shell），比如ifconfig，同时该命令是同步的，也就是说需要等到命令执行完毕才返回
...               - Start Command一般用于非交互式的命令，但该命令式异步的，就是说是在后台执行，会立即返回，命令的结果使用Read Command Output读取
...               - Write一般用于交互式的命令（所有的Write在一个shell上），比如需要输入Y/N的命令或者对环境变量有依赖的命令，该命令的返回信息通过Read，Read Until Prompt等读取
...
...               ---
...               3. *Sta发包: 编辑报文*
...               - 分层编辑报文，目前提供的关键字有：Build Ether; Build Dot1Q; Build Ip; Build Ipv6; 具体用法参见各关键字说明
...               - 通过关键字Build Packet组装各层报文，*注意: 各层报文要按从从低到高顺序编辑*
...               - *注意:目前只支持单层tag*
...
...               举例:
...               | Sta.Build Ether | dst=00:00:00:00:00:02 | src=00:00:00:00:00:01 |
...               | Sta.Build Dot1q | vlan=${10} | prio=${7} |
...               | Sta.Build Ip | dst=10.1.1.1 | src=20.1.1.2 |
...               | Sta.Build Packet |
...
...               ---
...               4. *Sta发包: 将编辑的报文设置到接口*
...               - 通过关键字Set Stream Packet将编辑好的报文设置到端口
...
...               ---
...               5. *Sta发包: 设置发送报文的属性*
...               - 通过关键字Set Stream Control设置流的发送参数
...               - *注意: 发送速率有bps和pps两个参数，设置时只能设置1个参数，不能同时指定*
...               - *注意: 参数count是发送的数目，设置为0时是持续发送，但因为目前不支持速率统计，在测试中这种方式很难做精确的检查*
...
...               ---
...               6. *Sta发包: 发包和停止*
...               - 关键字: Start Transmit; \ Stop Transmit
...
...               ---
...               7. *Sta发包: 抓包过滤:*
...               - 抓包关键字: Start Capture
...               - 停止抓包关键字: Stop Capture
...               - 获取抓包的数量: Get Capture Packet Num
...               - 获取过滤报文的数量: Get Filter Capture Packet Num,
...               - *注意: 必须在抓包结束后，过滤报文的关键字才能使用;*
...               - *按不同条件，可以对抓到的报文反复使用不同的过滤条件过滤; 具体使用方法见关键字说明*
...
...               ---
...               8. *常用命令:*
...               - Sta Wep Open Connect
...               - Sta Wep Shared Connect
...               - Sta Wpa Open Connect
...               - Sta Wpa Psk Connect
...               - Sta Wpa2 Psk Connect
...               - Sta Wpa Eap Connect
...               - Sta Wpa2 Eap Connect
...               - Sta Wap Disconnect
...               - Sta Dhclient
...               - Sta Get Interface Ip
...               - Check Sta Ping
...
...               ---
...               9. *注意事项*
...               - 命令执行结束的标志为匹配到提示符，timeout时间为1分钟，如果命令的执行时间多于1分钟，用Sa.Set Client Configuration暂时修改timeout时间，然后执行完毕后再恢复默认值
...               - Sta发包 采用的是pktgen，因此只支持设置mac，ip，vlan，ipv6，不支持tcp，icmp，arp等协议
...               - 在同一个Sta上，同时只能有1个interface发包，暂时不支持多个interface同时发包
...               - Sta发包 不支持速率统计，在测试中请使用抓包方式来检查
Library           SSHLibrary
Library           ../lib/Tools.py
Library           ../lib/Pktgen.py
Library           String
Library           Collections

*** Variables ***
${sc_prompt}      \#
${sc_timeout}     ${60}
${sc_newline}     ${None}
${sc_path_separator}    ${None}

*** Keywords ***
Open SSH Connection
    [Arguments]    ${host}    ${alias}    ${username}    ${password}    ${port}=${22}
    [Documentation]    Opens a new SSH connection to the given `host` and `port`. and login by username and password
    ...
    ...    The new connection is made active. Possible existing connections are left open in the background.
    ...
    ...    `alias` can be given for the connection and can be used for switching between connections, similarly as the index.See `Switch Connection` for more details.
    ...
    ...    All the arguments, except `host`, `alias` and `port`can be later updated with `Set Client Configuration`.
    ...
    ...    Port `22` is assumed by default:
    ...    | Open SSH Connection | 192.168.1.1 | ${stat} |
    ...
    ...    Non-standard port may be given as an argument:
    ...    | Open SSH Connection | 192.168.1.1 | ${stat} | port=23 |
    SSHLibrary.Open Connection    ${host}    ${alias}    port=${port}    timeout=${sc_timeout}    prompt=${sc_prompt}    newline=${sc_newline}
    ...    path_separator=${sc_path_separator}
    SSHLibrary.Login    ${username}    ${password}

Close SSH Connection
    [Arguments]    ${alias}
    [Documentation]    Closes the \ connection.
    ...
    ...    Example:
    ...    | Close Connection | ${stat} |
    SSHLibrary.Switch Connection    ${alias}
    SSHLibrary.Close Connection

Close All SSH Connections
    [Documentation]    Closes all open connections.
    ...
    ...    \ \ \ \ \ This keyword is ought to be used either in test or suite teardown to
    ...    \ \ \ \ make sure all the connections are closed before the test execution
    ...    \ \ \ finishes.
    ...
    ...    \ Example:
    ...    | # Do something with the connections \ \ \ \ |
    ...    | [Teardown] \ \ \ \ \ | Close all connections |
    SSHLibrary.Close All Connections

Execute Command
    [Arguments]    ${alias}    ${cmd}    ${return_stdout}=${True}    ${return_stderr}=${False}    ${return_rc}=${False}
    [Documentation]    Executes `command` on the remote machine and returns its outputs.
    ...
    ...    \ \ \ \ \ This keyword executes the `command` and returns after the execution
    ...    \ \ \ \ has been finished. Use `Start Command` if the command should be
    ...    \ \ \ started on the background.
    ...
    ...    \ By default, only the standard output is returned:
    ...    | ${stdout}= \ \ \ \ | Execute Command | ${stat} | echo 'Hello John!' |
    ...    | Should Contain | ${stdout} \ \ \ \ \ \ | Hello John! \ \ \ \ \ \ \ |
    ...
    ...    Arguments `return_stdout`, `return_stderr` and `return_rc` are used
    ...    to specify, what is returned by this keyword.
    ...    If several arguments evaluate to true, multiple values are returned.
    ...    Non-empty strings, except `false` and `False`, evaluate to true.
    ...
    ...    If errors are needed as well, set the respective argument value to true:
    ...    | ${stdout} \ \ \ \ \ \ | ${stderr}= | Execute Command | ${stat} | echo 'Hello John!' | return_stderr=${True} |
    ...    | Should Be Empty | ${stderr} \ |
    ...
    ...    Often checking the return code is enough:
    ...    | ${rc}= \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ | Execute Command | ${stat} | echo 'Hello John!' | return_stdout=${False} | return_rc=${True} |
    ...    | Should Be Equal As Integers | ${rc} \ \ \ \ \ \ \ \ \ \ | 0 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ | # succeeded \ \ \ \ \ \ \ \ |
    ...
    ...    The `command` is always executed in a new shell. Thus possible changes
    ...    to the environment (e.g. changing working directory) are not visible
    ...    to the later keywords:
    ...    | ${pwd}= \ \ \ \ \ \ \ \ | Execute Command | ${stat} | pwd \ \ \ \ \ \ \ \ \ \ |
    ...    | Should Be Equal | ${pwd} \ \ \ \ \ \ \ \ \ | /home/johndoe |
    ...    | Execute Command | ${stat} | cd /tmp \ \ \ \ \ \ \ \ |
    ...    | ${pwd}= \ \ \ \ \ \ \ \ | Execute Command | ${stat} | pwd \ \ \ \ \ \ \ \ \ \ |
    ...    | Should Be Equal | ${pwd} \ \ \ \ \ \ \ \ \ | /home/johndoe |
    ...
    ...    `Write` and `Read` can be used for
    ...    [#Interactive shells|running multiple commands in the same shell].
    ...
    ...    This keyword logs the executed command and its exit status with
    ...    log level `INFO`.
    SSHLibrary.Switch Connection    ${alias}
    ${output}=    SSHLibrary.Execute Command    ${cmd}    return_stdout=${return_stdout}    return_stderr=${return_stderr}    return_rc=${return_rc}
    [Return]    ${output}

Start Command
    [Arguments]    ${alias}    ${cmd}
    [Documentation]    Starts execution of the `command` on the remote machine and returns immediately.
    ...
    ...    \ \ \ \ \ This keyword returns nothing and does not wait for the `command`
    ...    \ \ \ \ execution to be finished. If waiting for the output is required,
    ...    \ \ \ use `Execute Command` instead.
    ...
    ...    \ This keyword does not return any output generated by the started
    ...    `command`. Use `Read Command Output` to read the output:
    ...    | Start Command \ \ | ${stat} | echo 'Hello John!' \ |
    ...    | ${stdout}= \ \ \ \ \ | Read Command Output | ${stat} |
    ...    | Should Contain \ | ${stdout} \ \ \ \ \ \ \ \ \ \ | Hello John! |
    ...
    ...    The `command` is always executed in a new shell, similarly as with
    ...    `Execute Command`. Thus possible changes to the environment
    ...    (e.g. changing working directory) are not visible to the later keywords:
    ...    | Start Command \ \ | ${stat} | pwd \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | ${pwd}= \ \ \ \ \ \ \ \ | Read Command Output |
    ...    | Should Be Equal | ${pwd} \ \ \ \ \ \ \ \ \ \ \ \ \ | /home/johndoe |
    ...    | Start Command \ \ | ${stat} | cd /tmp \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | Start Command \ \ | ${stat} | pwd \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | ${pwd}= \ \ \ \ \ \ \ \ | Read Command Output | ${stat} |
    ...    | Should Be Equal | ${pwd} \ \ \ \ \ \ \ \ \ \ \ \ \ | /home/johndoe |
    ...
    ...    `Write` and `Read` can be used for
    ...    [#Interactive shells|running multiple commands in the same shell].
    ...
    ...    This keyword logs the started command with log level `INFO`.
    SSHLibrary.Switch Connection    ${alias}
    SSHLibrary.Start Command    ${cmd}

Read Command Output
    [Arguments]    ${alias}    ${return_stdout}=${True}    ${return_stderr}=${False}    ${return_rc}=${False}
    [Documentation]    Returns outputs of the most recent started command.
    ...
    ...    \ \ \ \ \ At least one command must have been started using `Start Command`
    ...    \ \ \ \ before this keyword can be used.
    ...
    ...    \ \ By default, only the standard output of the started command is returned:
    ...    \ | Start Command \ | ${stat} | echo 'Hello John!' \ |
    ...    | ${stdout}= \ \ \ \ | Read Command Output | ${stat} |
    ...    | Should Contain | ${stdout} \ \ \ \ \ \ \ \ \ \ | Hello John! |
    ...
    ...    Arguments `return_stdout`, `return_stderr` and `return_rc` are used
    ...    to specify, what is returned by this keyword.
    ...    If several arguments evaluate to true, multiple values are returned.
    ...    Non-empty strings, except `false` and `False`, evaluate to true.
    ...
    ...    If errors are needed as well, set the argument value to true:
    ...    | Start Command \ \ | ${stat} | echo 'Hello John!' |
    ...    | ${stdout} \ \ \ \ \ \ | ${stderr}= \ \ \ \ \ \ \ \ | Read Command Output | ${stat} | return_stderr=True |
    ...    | Should Be Empty | ${stderr} \ \ \ \ \ \ \ \ \ |
    ...
    ...    Often checking the return code is enough:
    ...    | Start Command \ \ \ \ \ \ \ \ \ \ \ \ \ \ | ${stat} | echo 'Hello John!' \ |
    ...    | ${rc}= \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ | Read Command Output | ${stat} | return_stdout=False | return_rc=True |
    ...    | Should Be Equal As Integers | ${rc} \ \ \ \ \ \ \ \ \ \ \ \ \ \ | 0 \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ | # succeeded \ \ \ |
    ...
    ...    Using `Start Command` and `Read Command Output` follows
    ...    'last in, first out' (LIFO) policy, meaning that `Read Command Output`
    ...    operates on the most recent started command, after which that command
    ...    is discarded and its output cannot be read again.
    ...
    ...    If several commands have been started, the output of the last started
    ...    command is returned. After that, a subsequent call will return the
    ...    output of the new last (originally the second last) command:
    ...    | Start Command \ | ${stat} | echo 'HELLO' \ \ \ \ \ \ \ |
    ...    | Start Command \ | ${stat} | echo 'SECOND' \ \ \ \ \ \ |
    ...    | ${stdout}= \ \ \ \ | Read Command Output | ${stat} |
    ...    | Should Contain | ${stdout} \ \ \ \ \ \ \ \ \ \ | 'SECOND' |
    ...    | ${stdout}= \ \ \ \ | Read Command Output | ${stat} |
    ...    | Should Contain | ${stdout} \ \ \ \ \ \ \ \ \ \ | 'HELLO' \ |
    ...
    ...    This keyword logs the read command with log level `INFO`.
    SSHLibrary.Switch Connection    ${alias}
    ${output}=    SSHLibrary.Read Command Output    return_stdout=${return_stdout}    return_stderr=${return_stderr}    return_rc=${return_rc}
    [Return]    ${output}

Execute Sudo Command
    [Arguments]    ${alias}    ${cmd}    ${password}    ${return_stdout}=${True}    ${return_stderr}=${False}    ${return_rc}=${False}
    [Documentation]    为了执行特权命令，加入sudo的支持，与Execute Command类似
    ...
    ...    args:
    ...    - ${alias}: sta别名
    ...    - ${cmd}: 命令
    ...    - ${password}: 密码
    ...    - ${return_stdout}: 返回stdout的信息，默认为True
    ...    - ${return_stderr}: 返回stderr的信息，默认为False
    ...    - ${return_rc}: 返回命令执行的返回值，默认为False
    SSHLibrary.Switch Connection    ${alias}
    SSHLibrary.Write    sudo ${cmd}
    SSHLibrary.Read Until    :
    SSHLibrary.Write    ${password}
    ${output}=    SSHLibrary.Read Until Prompt
    [Return]    ${output}

Write
    [Arguments]    ${alias}    ${text}
    [Documentation]    Writes the given `text` on the remote machine and appends a newline.
    ...
    ...    \ \ \ \ \ This keyword returns and [#Interactive shells|consumes] the written
    ...    \ \ \ \ `text` (including the appended newline) from the server output.
    ...
    ...    \ \ Example:
    ...    \ | ${written}= \ \ \ \ \ \ \ | Write \ \ \ \ \ \ \ \ | ${stat} | su \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | Should Contain \ \ \ \ | ${written} \ \ \ | su \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ | # Returns the consumed output \ |
    ...    | ${output}= \ \ \ \ \ \ \ \ | Read \ \ \ \ \ \ \ \ \ | ${stat} |
    ...    | Should Not Contain | ${output} \ \ \ \ | ${written} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ | # Was consumed from the output |
    ...    | Should Contain \ \ \ \ | ${output} \ \ \ \ | Password: \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | Write \ \ \ \ \ \ \ \ \ \ \ \ \ | ${stat} | invalidpasswd |
    ...    | ${output}= \ \ \ \ \ \ \ \ | Read \ \ \ \ \ \ \ \ \ | ${stat} |
    ...    | Should Contain \ \ \ \ | ${output} \ \ \ \ | su: Authentication failure |
    ...
    ...    See also `Write Bare`.
    SSHLibrary.Switch Connection    ${alias}
    ${output}=    SSHLibrary.Write    ${text}
    [Return]    ${output}=

Write Bare
    [Arguments]    ${alias}    ${text}
    [Documentation]    Writes the given `text` on the remote machine without appending a newline.
    ...
    ...    \ \ \ \ \ Unlike `Write`, this keyword returns and [#Interactive shells|consumes]
    ...    \ \ \ \ nothing.
    ...
    ...    \ \ Example:
    ...    \ | Write Bare \ \ \ \ | ${stat} | su\ \ \ \ \ |
    ...    | ${output}= \ \ \ \ | Read \ \ \ \ \ \ \ \ \ \ \ \ | ${stat} |
    ...    | Should Contain | ${output} \ \ \ \ \ \ \ | su \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ | # Was not consumed from output |
    ...    | Should Contain | ${output} \ \ \ \ \ \ \ | Password: \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | Write Bare \ \ \ \ | ${stat} | invalidpasswd\ |
    ...    | ${output}= \ \ \ \ | Read \ \ \ \ \ \ \ \ \ \ \ \ | ${stat} |
    ...    | Should Contain | ${output} \ \ \ \ \ \ \ | su: Authentication failure |
    ...
    ...    See also `Write`.
    SSHLibrary.Switch Connection    ${alias}
    SSHLibrary.Write Bare    ${text}

Read
    [Arguments]    ${alias}    ${delay}=${None}
    [Documentation]    Consumes and returns everything available on the server output.
    ...
    ...    \ \ \ \ \ If `delay` is given, this keyword waits that amount of time and reads
    ...    \ \ \ \ output again. This wait-read cycle is repeated as long as further reads
    ...    \ \ \ return more output or the [#Default timeout|timeout] expires.
    ...    \ \ `delay` must be given in Robot Framework's time format (e.g. `5`,
    ...    \ `4.5s`, `3 minutes`, `2 min 3 sec`) that is explained in detail in
    ...    the User Guide.
    ...
    ...    This keyword is most useful for reading everything from
    ...    the server output, thus clearing it.
    ...
    ...    Example:
    ...    | Write \ \ \ \ \ \ \ \ \ \ | ${stat} | sudo su - \ \ \ \ | \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | ${output}= \ \ \ \ \ | Read \ \ \ \ \ \ \ \ \ | ${stat} | delay=0.5s \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | Should Contain \ | ${output} \ \ \ \ | [sudo] password for johndoe: |
    ...    | Write \ \ \ \ \ \ \ \ \ \ | ${stat} | secretpasswd \ | \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | ${output}= \ \ \ \ \ | Read \ \ \ \ \ \ \ \ \ | ${stat} | # Shown in the console due to loglevel |
    ...    | Should Contain \ | ${output} \ \ \ \ | root@ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    SSHLibrary.Switch Connection    ${alias}
    ${output}=    SSHLibrary.Read    delay=${delay}
    [Return]    ${output}

Read Until Prompt
    [Arguments]    ${alias}    ${timeout}=${None}
    [Documentation]    Consumes and returns the server output until the prompt is found.
    ...
    ...    \ \ \ \ \ Text up and until prompt is returned. [#Default prompt|The prompt must
    ...    \ \ \ \ be set] before this keyword is used.
    ...
    ...    \ \ If [#Default timeout|the timeout] expires before the match is found,
    ...    \ this keyword fails.
    ...
    ...    This keyword is useful for reading output of a single command when
    ...    output of previous command has been read and that command does not
    ...    produce prompt characters in its output.
    ...
    ...
    ...    Example:
    ...    | Write \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ | ${stat} | sudo su - \ \ \ \ \ \ \ \ | \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | Write \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ | ${stat} | ${PASSWORD} \ \ \ \ \ \ | \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | Set Client Configuration | ${stat} | \ prompt=# \ \ \ \ \ \ \ \ \ | # For root, the prompt is # |
    ...    | ${output}= \ \ \ \ \ \ \ \ \ \ \ \ \ \ | Read Until Prompt | ${stat} |
    ...    | Should End With \ \ \ \ \ \ \ \ \ | ${output} \ \ \ \ \ \ \ \ | root@myserver:~# |
    SSHLibrary.Switch Connection    ${alias}
    ${timeoutFlag}=    Tools.Is None    ${timeout}
    Run Keyword If    not ${timeoutFlag}    SSHLibrary.Set Client Configuration    timeout=${timeout}
    ${output}=    SSHLibrary.Read Until Prompt
    Run Keyword If    not ${timeoutFlag}    SSHLibrary.Set Client Configuration    timeout=${sc_timeout}
    [Return]    ${output}

Read Until Regexp
    [Arguments]    ${alias}    ${regexp}    ${timeout}=${None}
    [Documentation]    Consumes and returns the server output until a match to `regexp` is found.
    ...
    ...    \ \ \ \ \ `regexp` can be a pattern or a compiled regexp object.
    ...
    ...    \ \ \ Text up until and including the `regexp` will be returned.
    ...
    ...    \ Regular expression check is implemented using the Python
    ...    [http://docs.python.org/2/library/re.html|re module]. Python's regular
    ...    expression syntax is derived from Perl, and it is thus also very
    ...    similar to the syntax used, for example, in Java, Ruby and .NET.
    ...
    ...    Things to note about the `regexp` syntax:
    ...
    ...    - Backslash is an escape character in the test data, and possible
    ...    backslashes in the pattern must thus be escaped with another backslash
    ...    (e.g. '\\\\d\\\\w+').
    ...
    ...    - Possible flags altering how the expression is parsed (e.g.
    ...    re.IGNORECASE, re.MULTILINE) can be set by prefixing the pattern with
    ...    the '(?iLmsux)' group (e.g. '(?im)pattern'). The available flags are
    ...    'IGNORECASE': 'i', 'MULTILINE': 'm', 'DOTALL': 's', 'VERBOSE': 'x',
    ...    'UNICODE': 'u', and 'LOCALE': 'L'.
    ...
    ...    If [#Default timeout|the timeout] expires before the match is found,
    ...    this keyword fails.
    ...
    ...    Example:
    ...    | Write \ \ \ \ \ \ \ \ \ \ | ${stat} | sudo su - \ \ \ \ \ \ \ \ | \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | ${output}= \ \ \ \ \ | Read Until Regexp | ${stat} | \\\\[.*\\\\].*: \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | Should Contain \ | ${output} \ \ \ \ \ \ \ \ | [sudo] password for johndoe: |
    ...    | Write \ \ \ \ \ \ \ \ \ \ | ${stat} | ${PASSWORD} \ \ \ \ \ \ | \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | ${output}= \ \ \ \ \ | Read Until Regexp | ${stat} | .*@ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    ...    | Should Contain \ | ${output} \ \ \ \ \ \ \ \ | root@ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ |
    SSHLibrary.Switch Connection    ${alias}
    ${timeoutFlag}=    Tools.Is None    ${timeout}
    Run Keyword If    not ${timeoutFlag}    SSHLibrary.Set Client Configuration    timeout=${timeout}
    ${output}=    SSHLibrary.Read Until Regexp    ${regexp}
    Run Keyword If    not ${timeoutFlag}    SSHLibrary.Set Client Configuration    timeout=${timeout}
    [Return]    ${output}

Set Client Configuration
    [Arguments]    ${alias}    ${timeout}=${None}    ${newline}=${None}    ${prompt}=${None}    ${term_type}=${None}    ${width}=${None}
    ...    ${height}=${None}    ${path_separator}=${None}    ${encoding}=${None}
    [Documentation]    Update the `configuration` of the current connection.
    ...
    ...    \ \ \ \ \ Only parameters whose value is other than `None` are updated.
    ...
    ...    \ \ \ In the following example, [#Default prompt|`prompt`] is set for
    ...    \ \ the current connection. Other settings are left intact:
    ...    \ | Set Client Configuration | ${stat} | prompt=$ \ \ \ \ \ \ \ \ \ \ |
    ...
    ...    Using keyword does not affect the other connections:
    ...    | Set Client Configuration | ${stat} | prompt=$ \ \ \ \ \ \ \ \ \ \ | \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ | # Only linux.server.com affected \ \ |
    ...    | Set Client Configuration | ${stat} | prompt=> \ \ \ \ \ \ \ \ \ \ | \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ | # Only windows.server.com affected |
    ...
    ...    Multiple settings are possible. This example updates [#Default terminal
    ...    settings|the terminal settings] of the current connection:
    ...    | Set Client Configuration | term_type=ansi | width=40 |
    ...
    ...    Arguments [#Default path separator|`path_separator`] and
    ...    [#Default encoding|`encoding`]
    ...    were added in SSHLibrary 2.0.
    SSHLibrary.Switch Connection    ${alias}
    SSHLibrary.Set Client Configuration    timeout=${timeout}    newline=${newline}    prompt=${prompt}    term_type=${term_type}    width=${width}    height=${height}
    ...    path_separator=${path_separator}    encoding=${encoding}

Sta Wpa Disconnect
    [Arguments]    ${alias}    ${netcard_name}    ${forceFlag}=${False}
    [Documentation]    断开连接
    ...
    ...    args：
    ...    - ${alias}: sta别名
    ...    - ${netcard_name}: 接口名称
    ...    - ${forceFlag}: 强制接口down/up，默认False
    Sta.Execute Command    ${alias}    dhclient -r ${netcard_name}
    Run Keyword If    ${forceFlag}    Sta.Execute Command    ${alias}    ifconfig ${netcard_name} down
    Sta.Execute Command    ${alias}    wpa_cli -i ${netcard_name} disable_network 0
    Sta.Execute Command    ${alias}    wpa_cli -i ${netcard_name} remove_network 0
    Sta.Execute Command    ${alias}    dhclient -r ${netcard_name}
    Run Keyword If    ${forceFlag}    Sta.Execute Command    ${alias}    ifconfig ${netcard_name} up
    Sleep    2

For Sta Wpa Connect WirelessNetwork1
    [Arguments]    ${alias}    ${netcard_name}    ${ssid}    ${bssid}=${None}
    [Documentation]    在Sta Wpa Open Connect WirelessNetwork等关键字中使用，请勿单独使用
    Sta.Write    ${alias}    dhclient -r ${netcard_name}
    Sta.Read Until Prompt    ${alias}
    Sleep    2
    Sta.Write    ${alias}    ifconfig ${netcard_name} up
    Sta.Read Until Prompt    ${alias}
    Sleep    2
    Sta.Write    ${alias}    dmesg -c | grep ppppppppppp
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} remove_network 0
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} add_network 0
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 ssid '"${ssid}"'
    Sta.Read Until Prompt    ${alias}
    ${bssidFlag}=    Tools.Is None    ${bssid}
    ${transBssid}=    Run Keyword If    not ${bssidFlag}    Tools.Convert Macaddress Format    ${bssid}    -    :
    Run Keyword If    not ${bssidFlag}    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 bssid ${transBssid}
    Run Keyword If    not ${bssidFlag}    Sta.Read Until Prompt    ${alias}

Sta Wpa Open Connect
    [Arguments]    ${alias}    ${netcard_name}    ${ssid}    ${bssid}=${None}
    [Documentation]    参数：
    ...    - netcard_name: 网卡名称，比如wlan0
    ...    - ssid：
    ...    - bssid：默认为None，可以不填
    ...
    ...    返回：关联是否成功
    ...    - True：成功
    ...    - False：不成功
    Sta.For Sta Wpa Connect WirelessNetwork1    ${alias}    ${netcard_name}    ${ssid}    ${bssid}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 key_mgmt NONE
    Sta.Read Until Prompt    ${alias}
    ${retFlag}=    Sta.For Sta Wpa Connect WirelessNetwork2    ${alias}    ${netcard_name}    ${ssid}
    [Return]    ${retFlag}

Sta Wpa Psk Connect
    [Arguments]    ${alias}    ${netcard_name}    ${ssid}    ${psk}    ${encryption}    ${bssid}=${None}
    [Documentation]    参数：
    ...    - netcard_name: 网卡名称，比如wlan0
    ...    - ssid：
    ...    - psk:
    ...    - encryption: 加密算法 选择 CCMP TKIP
    ...    - bssid：默认为None，可以不填
    ...
    ...    返回：关联是否成功
    ...    - True：成功
    ...    - False：不成功
    Sta.For Sta Wpa Connect WirelessNetwork1    ${alias}    ${netcard_name}    ${ssid}    ${bssid}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 key_mgmt WPA-PSK
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 proto WPA
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 pairwise ${encryption}
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 group ${encryption}
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 psk '"${psk}"'
    Sta.Read Until Prompt    ${alias}
    ${retFlag}=    Sta.For Sta Wpa Connect WirelessNetwork2    ${alias}    ${netcard_name}    ${ssid}
    [Return]    ${retFlag}

Sta Wpa2 Psk Connect
    [Arguments]    ${alias}    ${netcard_name}    ${ssid}    ${psk}    ${encryption}    ${bssid}=${None}
    [Documentation]    参数：
    ...    - netcard_name: 网卡名称，比如wlan0
    ...    - ssid：
    ...    - psk:
    ...    - encryption: 加密算法 选择 CCMP TKIP
    ...    - bssid：默认为None，可以不填
    ...
    ...    返回：关联是否成功
    ...    - True：成功
    ...    - False：不成功
    Sta.For Sta Wpa Connect WirelessNetwork1    ${alias}    ${netcard_name}    ${ssid}    ${bssid}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 key_mgmt WPA-PSK
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 proto WPA2
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 pairwise ${encryption}
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 group ${encryption}
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 psk '"${psk}"'
    Sta.Read Until Prompt    ${alias}
    ${retFlag}=    Sta.For Sta Wpa Connect WirelessNetwork2    ${alias}    ${netcard_name}    ${ssid}
    [Return]    ${retFlag}

For Sta Wpa Connect WirelessNetwork2
    [Arguments]    ${alias}    ${netcard_name}    ${ssid}
    [Documentation]    在Sta Wpa Open Connect WirelessNetwork等关键字中使用，请勿单独使用
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} enable_network 0
    Sta.Read Until Prompt    ${alias}
    : FOR    ${index}    IN RANGE    0    16
    \    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} status
    \    ${output}=    Sta.Read Until Prompt    ${alias}
    \    ${matchFlag}=    Tools.Is Match From String    ${output}    (?is)ssid=${ssid}.*?wpa_state=COMPLETED
    \    Run Keyword If    ${matchFlag}    Exit For Loop
    \    Sleep    5
    [Return]    ${matchFlag}

Sta Dhclient
    [Arguments]    ${alias}    ${netcard_name}    ${timeout}=${60}
    [Documentation]    station 通过dhcp获取地址
    ...
    ...    参数
    ...    - timeout : 默认60s，执行dhclient获取地址的命令后，等待的时间
    ...
    ...    返回：
    ...    True：成功获取
    ...    False：未获取
    ...
    ...    获取的地址请用Sta Get Interface Ip 关键字
    Sta.Write    ${alias}    dhclient -nw ${netcard_name}
    Sta.Read Until Prompt    ${alias}
    Sleep    ${timeout}
    ${ip}=    Sta.Sta Get Interface Ip    ${alias}    ${netcard_name}
    ${retFlag}=    Tools.Is None    ${ip}
    ${retFlag}=    Evaluate    not ${retFlag}
    [Return]    ${retFlag}

Check Sta Ping
    [Arguments]    ${alias}    ${ipaddress}    ${pingCount}=10
    [Documentation]    注意：关键字返回的是ping失败率，如失败率为70%，则返回数字70
    ...
    ...    | Check Sta Ping | ${sta_alias} | 10.1.1.1 |
    ${output}=    Sta.Execute Command    ${alias}    ping ${ipaddress} -c ${pingCount}
    ${lossStr}=    Tools.Get Value From String    ${output}    (\\d+)% packet loss
    ${lossValue}=    Convert To Integer    ${lossStr}
    Log    ${output}
    [Return]    ${lossValue}

Sta Wep Open Connect
    [Arguments]    ${alias}    ${netcard_name}    ${ssid}    ${bssid}=${None}    ${key0}=${None}    ${key1}=${None}
    ...    ${key2}=${None}    ${key3}=${None}    ${txkey}=0    ${keytype}=${0}
    [Documentation]    参数：
    ...    - netcard_name: 网卡名称，比如wlan0
    ...    - ssid：
    ...    - key0---key3: 默认为None，用到哪个key，可直接使用keyX= 赋值，比如用到key0，key1，可以 | key0=123456 | \ key1=123456 |
    ...    - keytype： 默认值为0，0指ASCII格式； 1指HEX格式；这里的0,1是数字，不是字符，请注意
    ...    - txkey:
    ...    - bssid：默认为None，可以不填
    ...
    ...
    ...    返回：关联是否成功
    ...    - True：成功
    ...    - False：不成功
    Sta.For Sta Wpa Connect WirelessNetwork1    ${alias}    ${netcard_name}    ${ssid}    ${bssid}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 key_mgmt NONE
    Sta.Read Until Prompt    ${alias}
    ${keyFlag}=    Tools.Is None    ${key0}
    Run Keyword If    not ${keyFlag} and ${keytype} == 0    Set Test Variable    ${key0}    '"${key0}"'
    Run Keyword If    not ${keyFlag}    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 wep_key0 ${key0}
    Run Keyword If    not ${keyFlag}    Sta.Read Until Prompt    ${alias}
    ${keyFlag}=    Tools.Is None    ${key1}
    Run Keyword If    not ${keyFlag} and ${keytype} == 0    Set Test Variable    ${key1}    '"${key1}"'
    Run Keyword If    not ${keyFlag}    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 wep_key1 ${key1}
    Run Keyword If    not ${keyFlag}    Sta.Read Until Prompt    ${alias}
    ${keyFlag}=    Tools.Is None    ${key2}
    Run Keyword If    not ${keyFlag} and ${keytype} == 0    Set Test Variable    ${key2}    '"${key2}"'
    Run Keyword If    not ${keyFlag}    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 wep_key2 ${key2}
    Run Keyword If    not ${keyFlag}    Sta.Read Until Prompt    ${alias}
    ${keyFlag}=    Tools.Is None    ${key3}
    Run Keyword If    not ${keyFlag} and ${keytype} == 0    Set Test Variable    ${key3}    '"${key3}"'
    Run Keyword If    not ${keyFlag}    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 wep_key3 ${key3}
    Run Keyword If    not ${keyFlag}    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 wep_tx_keyidx ${txkey}
    Sta.Read Until Prompt    ${alias}
    ${retFlag}=    Sta.For Sta Wpa Connect WirelessNetwork2    ${alias}    ${netcard_name}    ${ssid}
    [Return]    ${retFlag}

Sta Wep Shared Connect
    [Arguments]    ${alias}    ${netcard_name}    ${ssid}    ${bssid}=${None}    ${key0}=${None}    ${key1}=${None}
    ...    ${key2}=${None}    ${key3}=${None}    ${txkey}=0    ${keytype}=${0}
    [Documentation]    参数：
    ...    - netcard_name: 网卡名称，比如wlan0
    ...    - ssid：
    ...    - key0---key3: 默认为None，用到哪个key，可直接使用keyX= 赋值，比如用到key0，key1，可以 | key0=123456 | \ key1=123456 |
    ...    - keytype： 默认值为0，0指ASCII格式； 1指HEX格式；这里的0,1是数字，不是字符，请注意
    ...    - txkey:
    ...    - bssid：默认为None，可以不填
    ...
    ...
    ...    返回：关联是否成功
    ...    - True：成功
    ...    - False：不成功
    Sta.For Sta Wpa Connect WirelessNetwork1    ${alias}    ${netcard_name}    ${ssid}    ${bssid}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 key_mgmt NONE
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 auth_alg SHARED
    Sta.Read Until Prompt    ${alias}
    ${keyFlag}=    Tools.Is None    ${key0}
    Run Keyword If    not ${keyFlag} and ${keytype} == 0    Set Test Variable    ${key0}    '"${key0}"'
    Run Keyword If    not ${keyFlag}    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 wep_key0 ${key0}
    Run Keyword If    not ${keyFlag}    Sta.Read Until Prompt    ${alias}
    ${keyFlag}=    Tools.Is None    ${key1}
    Run Keyword If    not ${keyFlag} and ${keytype} == 0    Set Test Variable    ${key1}    '"${key1}"'
    Run Keyword If    not ${keyFlag}    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 wep_key1 ${key1}
    Run Keyword If    not ${keyFlag}    Sta.Read Until Prompt    ${alias}
    ${keyFlag}=    Tools.Is None    ${key2}
    Run Keyword If    not ${keyFlag} and ${keytype} == 0    Set Test Variable    ${key2}    '"${key2}"'
    Run Keyword If    not ${keyFlag}    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 wep_key2 ${key2}
    Run Keyword If    not ${keyFlag}    Sta.Read Until Prompt    ${alias}
    ${keyFlag}=    Tools.Is None    ${key3}
    Run Keyword If    not ${keyFlag} and ${keytype} == 0    Set Test Variable    ${key3}    '"${key3}"'
    Run Keyword If    not ${keyFlag}    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 wep_key3 ${key3}
    Run Keyword If    not ${keyFlag}    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 wep_tx_keyidx ${txkey}
    Sta.Read Until Prompt    ${alias}
    ${retFlag}=    Sta.For Sta Wpa Connect WirelessNetwork2    ${alias}    ${netcard_name}    ${ssid}
    [Return]    ${retFlag}

Sta Wpa Eap Connect
    [Arguments]    ${alias}    ${netcard_name}    ${ssid}    ${identity}    ${password}    ${encryption}
    ...    ${bssid}=${None}
    [Documentation]    参数：
    ...    - netcard_name: 网卡名称，比如wlan0
    ...    - ssid：
    ...    - identity:
    ...    - password
    ...    - encryption: 加密算法 选择 CCMP TKIP
    ...    - bssid：默认为None，可以不填
    ...
    ...    返回：关联是否成功
    ...    - True：成功
    ...    - False：不成功
    Sta.For Sta Wpa Connect WirelessNetwork1    ${alias}    ${netcard_name}    ${ssid}    ${bssid}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 key_mgmt WPA-EAP
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 proto WPA
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 pairwise ${encryption}
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 group ${encryption}
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 eap PEAP
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 identity '"${identity}"'
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 password '"${password}"'
    Sta.Read Until Prompt    ${alias}
    ${retFlag}=    Sta.For Sta Wpa Connect WirelessNetwork2    ${alias}    ${netcard_name}    ${ssid}
    [Return]    ${retFlag}

Sta Wpa2 Eap Connect
    [Arguments]    ${alias}    ${netcard_name}    ${ssid}    ${identity}    ${password}    ${encryption}
    ...    ${bssid}=${None}
    [Documentation]    参数：
    ...    - netcard_name: 网卡名称，比如wlan0
    ...    - ssid：
    ...    - identity:
    ...    - password
    ...    - encryption: 加密算法 选择 CCMP TKIP
    ...    - bssid：默认为None，可以不填
    ...
    ...    返回：关联是否成功
    ...    - True：成功
    ...    - False：不成功
    Sta.For Sta Wpa Connect WirelessNetwork1    ${alias}    ${netcard_name}    ${ssid}    ${bssid}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 key_mgmt WPA-EAP
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 proto WPA2
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 pairwise ${encryption}
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 group ${encryption}
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 eap PEAP
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 identity '"${identity}"'
    Sta.Read Until Prompt    ${alias}
    Sta.Write    ${alias}    wpa_cli -i ${netcard_name} set_network 0 password '"${password}"'
    Sta.Read Until Prompt    ${alias}
    ${retFlag}=    Sta.For Sta Wpa Connect WirelessNetwork2    ${alias}    ${netcard_name}    ${ssid}
    [Return]    ${retFlag}

Sta Get Interface Ip
    [Arguments]    ${alias}    ${netcard_name}
    [Documentation]    获取接口的ip地址
    ...
    ...    args：
    ...    - ${alias}: sta别名
    ...    - ${netcard_name}: 接口名称
    ${output}=    Sta.Execute Command    ${alias}    ip -f inet addr show ${netcard_name}
    ${ipaddress}=    Tools.Get Value From String    ${output}    (?m)inet\\s+(\\d+\\.\\d+\\.\\d+\\.\\d+)
    [Return]    ${ipaddress}

Build Ether
    [Arguments]    ${dst}    ${src}    ${dst_mac_count}=${None}    ${src_mac_count}=${None}
    [Documentation]    build Ethernet field packet
    ...
    ...    args:
    ...    - dst \ \ \ : Dest Mac
    ...    - src \ \ \ : Source Mac
    ...    - dst_mac_count: default None
    ...    - src_mac_count: \ dafault None
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Ether | dst=00:00:00:00:00:01 | src=00:00:00:00:00:02 |
    ...    | Build Ether | src=00:00:00:00:00:02 \ | src_mac_count={10} |
    ...    | Build Ether | dst=00:00:00:00:00:02 | dst_mac_count={10} |
    ${plen}=    Pktgen.Build Ether    ${dst}    ${src}    ${dst_mac_count}    ${src_mac_count}
    [Return]    ${plen}

Build Dot1Q
    [Arguments]    ${prio}=${0}    ${vlan}=${1}
    [Documentation]    build 802.1Q field packet
    ...
    ...    args:
    ...    - prio \ \ \ = 0
    ...    - vlan \ \ \ = 1
    ...
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Dot1q | prio=${7} | vlan=${10} |
    ${packetlen}=    Pktgen.Build Dot1q    ${prio}    ${0}    ${vlan}
    [Return]    ${packetlen}

Build Ip
    [Arguments]    ${dst_ip_min}    ${src_ip_min}    ${tos}=${0x0}    ${dst_ip_max}=${None}    ${src_ip_max}=${None}
    [Documentation]    build ip field packet
    ...
    ...    args:
    ...    - dst_ip_min : \ \ \ \ dst ip
    ...    - src_ip_min : \ \ \ \ \ src ip
    ...    - tos \ \ \ \ type of service
    ...    - dst_ip_max \ : \ max dst ip
    ...    - src_ip_max \ : \ max src ip
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Ip | dst_ip_min=10.1.1.20 | src_ip_min=10.1.1.1 |
    ...    | Build Ip | dst_ip_min=10.1.1.20 | src_ip_min=10.1.1.1 | tos=${0} | dst_ip_max=10.1.1.30 |
    ${packetlen}=    Pktgen.Build Ip    ${tos}    ${dst_ip_min}    ${src_ip_min}    ${dst_ip_max}    ${src_ip_max}
    [Return]    ${packetlen}

Build Ipv6
    [Arguments]    ${dst_ipv6_min}    ${src_ipv6_min}    ${tc}=${0}    ${dst_ipv6_max}=${None}    ${src_ipv6_max}=None
    [Documentation]    build ipv6 field packet
    ...
    ...    args:
    ...    - dst_ipv6_min \ \ \ \ \ \ \ \ \ dst ipv6
    ...    - src_ipv6_min \ \ \ \ \ \ \ \ src ipv6
    ...    - tc \ \ \ \ \ \ \ \ = 0; \ \ \ \ \ \ \ \ traffic class
    ...    - dst_ipv6_max \ : \ dst ipv6 count
    ...    - src_ipv6_max \ : \ \ src ipv6 count
    ...
    ...    return:
    ...    - packet field length
    ...
    ...    exapmle:
    ...    | Build Ipv6 | dst_ipv6_min=2002::1 | src_ipv6_min=2001::1 |
    ...    | Build Ipv6 | dst_ipv6_min=2002::1 | src_ipv6_min=2001::1 | tc=${0} | dst_ipv6_max=${10} |
    ${packetlen}=    Pktgen.Build Ipv6    ${tc}    ${dst_ipv6_min}    ${src_ipv6_min}    ${dst_ipv6_max}    ${src_ipv6_max}
    [Return]    ${packetlen}

Set Stream Control
    [Arguments]    ${alias}    ${interface}    ${numPackets}    ${Rate}    ${RateP}
    [Documentation]    set stream trasmit mode
    ...
    ...    Note:please use this keyword after Set Stream Packet
    ...
    ...    args:
    ...    - ${alias}: sta别名
    ...    - interface: network interface
    ...    - numPackets: send packet num, 0 for loop
    ...    - Rate: stream send rate, bps
    ...    - RateP: pps
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ...
    ...    *参数Rate 和 RateP 只能配置1个，另一个可设置为None*
    ${rc}=    Pktgen.Set Stream Control    ${alias}    ${interface}    ${numPackets}    ${Rate}    ${RateP}
    [Return]    ${rc}

Build Packet
    [Arguments]    ${length}=${128}
    [Documentation]    将之前建立的各层字段组织为一个报文
    ...
    ...    参数：
    ...    - length \ \ \ \ : \ \ 报文长度
    ${rc}=    Pktgen.Build Packet    ${length}
    [Return]    ${rc}

Start Transmit
    [Arguments]    ${alias}    ${interface}    ${dev}=/proc/net/pktgen/kpktgend_0
    [Documentation]    start to transmit stream
    ...
    ...    args:
    ...    - ${alias}: sta别名
    ...    - interface: \ \ network interface
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    Sta.Stop Transmit    ${alias}    ${interface}    ${dev}
    Builtin.Comment    ${cmd_init}=    Pktgen.Init Pktgen
    Builtin.Comment    ${init_code}=    Sta.Execute Command    ${alias}    ${cmd_init}    return_stdout=${False}    return_rc=${True}
    Builtin.Comment    Should Be Equal As Integers    ${init_code}    ${0}    ${alias} can not load module \ pktgen,please check
    Builtin.Comment    ${cmd_check}=    Pktgen.Check Pktgen
    Builtin.Comment    ${check_code}=    Sta.Execute Command    ${alias}    ${cmd_check}    return_stdout=${False}    return_rc=${True}
    Builtin.Comment    Should Be Equal As Integers    ${check_code}    ${0}    ${alias} pktgen thread not run, please check
    ${cmd_list}    ${cmd_start}    Pktgen.Start Transmit    ${alias}    ${interface}
    Log Many    @{cmd_list}
    : FOR    ${cmd}    IN    @{cmd_list}
    \    Sta.Pktgen Set Dev    ${alias}    @{cmd}[0]    @{cmd}[1]    ${interface}
    Sta.Start Command    ${alias}    ${cmd_start}
    [Return]    ${0}

Stop Transmit
    [Arguments]    ${alias}    ${interface}    ${dev}=/proc/net/pktgen/kpktgend_0
    [Documentation]    stop to transmit stream
    ...
    ...    args:
    ...    - ${alias}: sta别名
    ...    - interface: \ \ network interface
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${cmd_init}=    Pktgen.Init Pktgen
    ${init_code}=    Sta.Execute Command    ${alias}    ${cmd_init}    return_stdout=${False}    return_rc=${True}
    Should Be Equal As Integers    ${init_code}    ${0}    ${alias} can not load module \ pktgen,please check
    ${cmd_check}=    Pktgen.Check Pktgen
    ${check_code}=    Sta.Execute Command    ${alias}    ${cmd_check}    return_stdout=${False}    return_rc=${True}
    Should Be Equal As Integers    ${check_code}    ${0}    ${alias} pktgen thread not run, please check
    ${check_stop}=    Sta.Execute Command    ${alias}    cat ${dev}
    ${stop_flag}=    Tools.Is Match From String    ${check_stop}    Stopped: ${interface}
    Run Keyword If    ${stop_flag}    Return From Keyword    ${0}
    ${cmd_stop}=    Pktgen.Stop Transmit    ${alias}    ${interface}
    ${rc}=    Sta.Execute Command    ${alias}    ${cmd_stop}    return_stdout=${False}    return_rc=${True}
    [Return]    ${rc}

Start Capture
    [Arguments]    ${alias}    ${interface}
    [Documentation]    start to capture stream
    ...
    ...    args:
    ...    - ${alias}: sta别名
    ...    - interface: \ \ network interface
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${cmd_check}=    Pktgen.Check Tcpdump
    ${check_code}=    Sta.Execute Command    ${alias}    ${cmd_check}    return_stdout=${False}    return_rc=${True}
    Should Be Equal As Integers    ${check_code}    ${0}    ${alias} not install tcpdump,please check
    ${cmd_check_P}=    Pktgen.Check Tcpdump Paramter In
    ${check_output}=    Sta.Execute Command    ${alias}    ${cmd_check_P}    return_stdout=${False}    return_stderr=${True}
    ${p_flag}=    Tools.Is Match From String    ${check_output}    -P in\\|out\\|inout
    ${cmd_start_cap}=    Pktgen.Start Capture    ${alias}    ${interface}    ${p_flag}
    Sta.Start Command    ${alias}    ${cmd_start_cap}

Stop Capture
    [Arguments]    ${alias}    ${interface}
    [Documentation]    stop to capture stream
    ...
    ...    args:
    ...    - ${alias}: sta别名
    ...    - interface: \ \ network interface
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${cmd_check}=    Pktgen.Check Tcpdump
    ${check_code}=    Sta.Execute Command    ${alias}    ${cmd_check}    return_stdout=${False}    return_rc=${True}
    Should Be Equal As Integers    ${check_code}    ${0}    ${alias} not install tcpdump,please check
    ${cmd_check_P}=    Pktgen.Check Tcpdump Paramter In
    ${check_output}=    Sta.Execute Command    ${alias}    ${cmd_check_P}    return_stdout=${False}    return_stderr=${True}
    ${p_flag}=    Tools.Is Match From String    ${check_output}    -P in\\|out\\|inout
    ${cmd_stop_cap}=    Pktgen.Stop Capture    ${alias}    ${interface}    ${p_flag}
    Sta.Execute Command    ${alias}    ${cmd_stop_cap}
    ${cmd_num}=    Pktgen.Get Capture Packet Num    ${alias}    ${interface}
    ${output_num}=    Sta.Execute Command    ${alias}    ${cmd_num}
    ${rc}=    Tools.Get Value From String    ${output_num}    (?m)^(\\d+)$
    [Return]    ${rc}

Get Filter Capture Packet Num
    [Arguments]    ${alias}    ${interface}    ${fliter_express}=${None}
    [Documentation]    filter the capture packet,and return a list including filter num and filter packets
    ...
    ...    Note:please use this keyword after Stop Capture
    ...
    ...    args:
    ...    - ${alias}: sta别名
    ...    - interface: \ \ network interface
    ...    - filter_express: filter expression, default None,not filter capture packets;to know detail information,please visit http://www.ferrisxu.com/WinPcap/html/index.html WinPcap用户指南--过滤串表达式的语法
    ...
    ...    return:
    ...    - num of filter packet
    ...
    ...    ---
    ...    过滤串表达式的语法：
    ...
    ...    注意：这篇文档取自tcpdump的指南。原始的版本 www.tcpdump.org 找到。
    ...
    ...    wpcap的过滤器是以已声明的谓词语法为基础的。过滤器是一个ASCII字符串，它包含了一个过滤表达式。pcap_compile()把这个表达式编译成内核级的包过滤器。
    ...    这个表达式会选择那些数据包将会被堆存。如果表达式没有给出，那么，网络上所有的包都会被内核过滤引擎所认可。不然，只有那些表达式为'true'的包才会被认可。
    ...
    ...    这个表达式包含了一个或多个原语。原语通常包含了id(名字或序列)，这些id优先于限定词。以下是三种不同的限定词：
    ...
    ...    输入(type)
    ...    指明了哪些东西是id所代表的。可能的输入是host，net和port。比如：`host foo'，`net 128.3'，`port 20'。如果没有输入限定词，就假定是host
    ...    方向(dir)
    ...    由id指明了一个特定的传输方向。可能的方向是src，dst，src or dst。比如，'src foo'，'dst net 128.3'，`src or dst port ftp-data'。如果没有指定，就假定是src or dst。如果没有链路层(比如，像slip这样的点对点协议)，那么限定词可以使用inbound和outbound，来指明一个方向。
    ...    协议(proto)
    ...    限定词限制了所匹配的协议。可能的协议有：ether，fddi，tr，ip，ip6，arp，rarp，decnet，tcp和udp。比如：`ether src foo'，`arp net 128.3'，`tcp port 21'。如果没有指定协议限定词，那么就假定所有的协议都会被允许。例如：'src foo'等价于'(ip or arp or rarp)src foo'(当然，不能有不符合语法的字母出现)，'net bar'等价于'(ip or arp or rarp) net bar'，'port53'等价于'(tcp or udp) port 53'。
    ...    [ 'fddi'通常是'ether'的别名；解析器会认为它们是在特定网络接口上的数据链路层。FDDI的首部包含了和以太网很相似的源地址和目的地址，并且通常也包含了和以太网很相似的数据包类型。所以，在FDDI网域上使用过滤器和在以太网上使用过滤器基本一致。FDDI的首部还包括了其他的数据，不过你不能在过滤器表达式内表示他们。
    ...
    ...    同样的，'tr'也是'ether'的一个别名，它是较早被应用于FDDI的首部，也应用在令牌环网络首部。]
    ...
    ...    除了以上内容，还有一些特殊的限定词和上面的形式不太一样，它们是：gateway，broadcast，less，greater和一些算术表达式。这些内容会在下面和大家介绍。
    ...
    ...    我们可以使用and，or和not将原语连接起来，来构造一个更复杂的过滤表达式。例如：`host foo and not port ftp and not port ftp-data'。如果要简化输入，我们可以把已列出的id限定词省略。比如：`tcp dst port ftp or ftp-data or domain' 和 `tcp dst port ftp or tcp dst port ftp-data or tcp dst port domain'是完全等价的。
    ...
    ...    可使用的原语有：
    ...
    ...    dst host host
    ...    当IPv4/v6数据包的目标域(destination field)为host时为true，host既可以是地址，也可以是名字。
    ...    src host host
    ...    当IPv4/v6数据包的源域(source field)为host时为true。
    ...    host host
    ...    当IPv4/v6数据包的源域(source field)或目标域(destination field)为host时为true。以上任何一个host表达式可以是ip，arp，rarp或ip6开头，如下所示：
    ...    ip host host
    ...    等价于：
    ...    ether proto \ip and host host
    ...    如果host是一个多IP地址，那么每一个地址都会被匹配。
    ...    ether dst ehost
    ...    当以太网的目的地址为ehost时为true。ehost可以是一个来自/etc/ether的名字，也可以是一个数字代号(参见 ethers(3N)for numeric format)。
    ...    ether src ehost
    ...    当以太网的源地址为ehost时为true。
    ...    ether host ehost
    ...    当以太网的目的地址，或源地址为ehost时为true。
    ...    gateway host
    ...    当host为网关时为true。即，以太网源地址或目的地址是host,但源地址和目的地址不同时为host。host必须能被机器的主机-IP地址(host-name-to-IP-address)机制找到(如主机名文件，DNS，NIS等)，也能被主机-以太网地址(host-name-to-Ethernet-address)机制找到(如/etc/ethers等)。例如：
    ...    ether host ehost and not host host
    ...    host / ehost均可使用名字或数字。这个语法目前在IPv6下不能工作。
    ...    dst net net
    ...    当IPv4/v6数据包的目的地址的网络号包含了net时为true。net可以是一个来自/etc/networks的名字，也可以是一个网络号(更多内容请参见 networks(4))。
    ...    src net net
    ...    当IPv4/v6数据包的源地址的网络号包含了net时为true。
    ...    net net
    ...    当IPv4/v6数据包的目的地址，或源地址的网络号包含了net时为true
    ...    net net mask netmask
    ...    当IP地址是 net ，子网掩码匹配 netmask 时为true。 可能需要 src 或 dst加以限制。 注意，这个语法不能应用于IPv6。
    ...    net net/len
    ...    当IP地址是 net ，子网掩码连续1的个数为 len 时为true。 可能需要 src 或 dst加以限制。
    ...    dst port port
    ...    当数据包是ip/tcp, ip/udp, ip6/tcp 或 ip6/udp，并且目的端口号是port时为true。port可以是数字，或是在/etc/services中被使用的名字。(参见 tcp(4P) and udp(4P))。如果使用名字，那么端口号和协议都将被检测。如果使用数字，或者一个不明确的名字，那么只有端口号会被检测。（比如：dst port 513将打印tcp/login数据流和udp/who数据流。port domain将打印tcp/domain的数据流和udp/domain的数据流）。
    ...    src port port
    ...    当源端口号是 port时为true。
    ...    port port
    ...    当源端口号或目的端口号为 port 时为true。以上任何一个port表达式可以以关键字tcp或udp开头，如下所示：
    ...    tcp src port port
    ...    只匹配源端口是 port 的tcp数据包。
    ...    less length
    ...    当数据包的长度小于等于length时为true。即：
    ...    len <= length.
    ...    greater length
    ...    当数据包的长度大于等于length时为true。即：
    ...    len >= length.
    ...    ip proto protocol
    ...    当数据包是IP数据包，并且它的协议类型为protocol时为true。protocol可以是一个数字，也可以是icmp, icmp6，igmp，igrp，pim，ah，esp，vrrp，udp 或 tcp中的一个。注意，tcp，udp， icmp是关键字，所以，它们要使用反斜杠(\)来转义，就好比C-shell中的\\。注意，这个原语不会去追踪协议首部链。
    ...    ip6 proto protocol
    ...    当数据包是IPv6数据包，并且它的协议类型为protocol时为true。注意，这个原语不会去追踪协议首部链。
    ...    ip6 protochain protocol
    ...    当数据包是IPv6数据包，并且，在它的协议首部链中，包含了protocol类型的协议首部时，为true。 例如：
    ...    ip6 protochain 6
    ...    能匹配所有的，拥有TCP协议首部的IPv6的数据包。在IPv6首部和TCP首部之间，可能包含认证首部，路由首部和跳数选项首部。由这个原语所生成的BPF(BSD Packet Filter，包过滤机制)码是复杂的，而且不能被BPF优化器优化，所以，在某些程度上，它的速度比较慢。
    ...    ip protochain protocol
    ...    功能和 ip6 protochain protocol相同，只是这个应用于 IPv4。
    ...    ether broadcast
    ...    当数据包是以太网广播数据包时为true。关键字ether是可选的。
    ...    ip broadcast
    ...    当数据包是IP广播数据包时为true。它会检查所有的广播，包括地址全是0的和地址全是1的，然后，检查子网掩码。
    ...    ether multicast
    ...    当数据包是以太网多播数据包时为true。关键字ether是可选的。 下面是一个常用短语`ether[0] & 1 != 0'
    ...    ip multicast
    ...    当数据包是IP多播数据包时为true。
    ...    ip6 multicast
    ...    当数据包是IPv6多播数据包时为true。
    ...    ether proto protocol
    ...    当数据包是以太类型的protocol时为true。protocol可以是一个数字，也可以是ip, ip6, arp, rarp, atalk, aarp,decnet, sca, lat, mopdl, moprc,iso, stp, ipx, netbeui中的一个。注意，这些符号也都是关键字，所以，他们都需要用反斜杠(\)转义。
    ...    [在使用FDDI(比如'fddi protocol arp')和令牌环(比如'tr protocol arp')和其他大多数这种协议时，协议根据802.2逻辑链路控制(LLC)来识别，这些信息通常在FDDI或令牌环首部的开始。
    ...    当需要识别大多数协议的标识，比如FDDI或令牌环时, Tcpdump只检查LLC报头的ID数据域，它们以SNAP格式存储，并且，组织单位识别码(Organizational Unit Identifier(OUI))为0x000000，以封装以太网。它不会检查这个包是不是SNAP格式的，并在0x000000单元有OUI。
    ...    然而，iso是个特例，它会检查LLC首部的目的服务存取点DSAP(Destination Service Access Point)和源服务存取点SSAP(Source Service Access Point)，stp和netbeui会检查LLC首部的DSAP，atalk会检查数据包是不是SNAP格式的，并且OUI是不是0x080007。Appletalk 同样如此。
    ...    在以太网的例子中，tcpdump检查大部分协议的以太网类型字段，iso，sap 和 netbeui除外，因为它们会检查802.3帧，然后检查LLC首部，就像它对FDDI和令牌环那样。atalk，它检查以太网帧的Appletalk etype和SNAP格式的以太网帧，arrp，它在以太网帧中检查Appletalk ARP etype，或是在OUI为0x000000的802.2 SNAP帧中查找，还有ipx，他会在以太网帧中检查IPX etype，在LLC首部检查IPX DSAP，没有用802.3封装的LLC首部的IPX，和SNAP帧中的IPX etype。]
    ...    decnet src host
    ...    当DECNET的源地址为host时为true，它可能是一个格式为'10.123'的地址，也可能是一个DECNET主机名。[DECNET主机名称只有在配置成可运行DECNET的Ultrix系统中才得到支持。]
    ...    decnet dst host
    ...    当DECNET的目的地址为host时为true。
    ...    decnet host host
    ...    当DECNET的源地址或目的地址为host时为true。
    ...    ip, ip6, arp, rarp, atalk, aarp, decnet, iso, stp, ipx, netbeui
    ...    缩写是：
    ...    ether proto p
    ...    p 是以上协议中的一个。
    ...    lat, moprc, mopdl
    ...    缩写是：
    ...    ether proto p
    ...    p 是以上协议中的一个。 注意： tcpdump 目前并不知道，如何解析出这些协议。
    ...    vlan [vlan_id]
    ...    当数据包是IEEE 802.1Q VLAN数据包时为true。若[vlan_id]被指定，则仅当数据包为指定的vlan_id，值才为true。注意，在假设数据包为VLAN数据包的前提下，表达式中的第一个关键字vlan会改变剩余表达式的解码偏移量。
    ...    tcp, udp, icmp
    ...    缩写是：
    ...    ip proto p or ip6 proto p
    ...    p 是以上协议中的一个。
    ...    iso proto protocol
    ...    当数据包的协议类型为protocol的OSI数据包时值为true。Protocol可以是一个数字或以下名称中的一个：clnp，esis或isis。
    ...    clnp, esis, isis
    ...    缩写是：
    ...    iso proto p
    ...    p 是以上协议中的一个。注意，tcpdump并不能完成这些协议的全部解析工作。
    ...    expr relop expr
    ...    若关系式如下：relop是 >, <, >=, <=, =, != 中的一个，并且expr是一个由正整常数（用标准C语言的语法表示），标准二进制运算符[ +, -, *, /, &, | ]，运算符的长度，和指定数据包存取，则值为true。要存取数据包内的数据，可以使用以下的语法：
    ...    proto [ expr : size ]
    ...    Proto 是 ether, fddi, tr, ip, arp, rarp, tcp, udp, icmp or ip6中的一个，它为索引操作指明了协议层。注意，tcp,udp和其他较高层的协议类型只能应用于IPv4，而不能用于IPv6(这个问题可能在将来能得到解决)。被指定的协议层的字节偏移量由expr给出。Size是可选的，它指明了数据域中，我们所感兴趣的字节数。它可以是1，2，或4，默认为1。运算符的长度，由关键字len给出，指明了数据包的长度。
    ...    例如，`ether[0] & 1 != 0'会捕捉所有的多播数据流。表达式`ip[0] & 0xf != 5'能捕捉所有带可选域的IP数据包。表达式`ip[6:2] & 0x1fff = 0'仅捕捉未分段的数据报和段偏移量是0的数据报。这个检查隐含在tcp和udp的下标操作中。例如，tcp[0]通常指第一个字节的TCP首部，而不是指第一个字节的分段。
    ...
    ...    有些偏移量和域值可以以名字来表示，而不是数值。以下协议首部域的偏移量是正确的：icmptype (ICMP 类型域), icmpcode (ICMP 代码域), and tcpflags (TCP 标志域)。
    ...
    ...    ICMP 类型域有以下这些： icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redirect, icmp-echo, icmp-routeradvert, icmp-routersolicit, icmp-timxceed, icmp-paramprob, icmp-tstamp, icmp-tstampreply, icmp-ireq, icmp-ireqreply, icmp-maskreq, icmp-maskreply.
    ...
    ...    TCP 标志域有以下这些： tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-push, tcp-ack, tcp-urg.
    ...
    ...    原语可以用以下内容组合：
    ...
    ...    用圆括号括起来的原语和操作符 (圆括号在Shell中是特殊符号，所以必须要转义)。
    ...    取反操作 (`!' 或 `not').
    ...    连接操作 (`&&' 或 `and').
    ...    选择操作 (`||' 或 `or').
    ...    取反操作的优先级最高。 连接操作和选择操作有相同的优先级，并且它们的结合方向为从左向右。 注意：做连接的时候是需要显示的 and 操作符的，而不是把要连接的东西写在一起。
    ...
    ...    如果给出一个标识符，却没有关键字，那么就会假定用最近使用的关键字。 例如：
    ...
    ...    not host vs and ace
    ...    等价于
    ...    not host vs and host ace
    ...    不能和下面的混淆
    ...    not ( host vs or ace )
    ...    表达式参数即可以作为单个参数，也可以作为多个参数传递给tcpdump，后者更加方便一些。一般的，如果表达式包含一个Shell的元字符，那么用一个参数传递比较容易，最好把它括起来，多个参数在传递前，用空格连接起来。
    ${cmd_num}=    Pktgen.Filter Capture Packet    ${alias}    ${interface}    ${fliter_express}
    ${output_num}=    Sta.Execute Command    ${alias}    ${cmd_num}
    ${rc}=    Tools.Get Value From String    ${output_num}    (?m)^(\\d+)$
    [Return]    ${rc}

Get Capture Packet Num
    [Arguments]    ${alias}    ${interface}
    [Documentation]    get capture packet num,please use this keyword after Start Capture and Stop Capture
    ...
    ...    args:
    ...    - ${alias}: sta别名
    ...    - interface: \ \ network interface
    ...
    ...    return:
    ...    - non negative number: num of capture packet
    ...    - negative number: error code
    ${cmd_num}=    Pktgen.Get Capture Packet Num    ${alias}    ${interface}
    ${output_num}=    Sta.Execute Command    ${alias}    ${cmd_num}
    ${rc}=    Tools.Get Value From String    ${output_num}    (?m)^(\\d+)$
    [Return]    ${rc}

Get Filter Capture Packet
    [Arguments]    ${alias}    ${interface}    ${filter_express}=${None}
    [Documentation]    get capture packet, and save internally
    ...
    ...    Note:please use this keyword after Start Capture and Stop Capture
    ...
    ...    args:
    ...    - ${alias}: sta别名
    ...    - interface: \ \ network interface
    ...    - filter_express: filter expression, default None,not filter capture packets;to know detail information,please visit http://www.ferrisxu.com/WinPcap/html/index.html WinPcap用户指南--过滤串表达式的语法
    ...
    ...    return:
    ...    - non negative number: num of capture packet
    ...    - negative number: error code
    ${cmd_num}=    Pktgen.Get Filter Capture Packet    ${alias}    ${interface}    ${filter_express}
    ${output_num}=    Sta.Execute Command    ${alias}    ${cmd_num}
    Log    ${output_num}
    [Return]    ${output_num}

Set Stream Packet
    [Arguments]    ${alias}    ${interface}
    [Documentation]    set a packet on interface of station
    ...
    ...    Note:please use this keyword after Build Packet
    ...
    ...    args:
    ...    - ${alias}: sta别名
    ...    - interface: \ \ network interface
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Pktgen.Set Stream Packet    ${alias}    ${interface}
    [Return]    ${rc}

Pktgen Set Dev
    [Arguments]    ${alias}    ${cmd}    ${dev}    ${iface}
    Sta.Execute Command    ${alias}    ${cmd}${dev}
    ${rate_result}=    Sta.Execute Command    ${alias}    cat ${dev}
    ${rate_flag}=    Tools.Is Match From String    ${rate_result}    Result: No such parameter "rate"|Result: No such parameter "ratep"
    ${delay_cmd}=    Run Keyword If    ${rate_flag}    Pktgen.Get Stream Delay    ${alias}    ${iface}
    Run Keyword If    ${rate_flag}    Sta.Execute Command    ${alias}    ${delay_cmd}${dev}
    ${result}=    Sta.Execute Command    ${alias}    cat ${dev}
    Should Match Regexp    ${result}    Result: OK

Sta Dhclient Return Ip
    [Arguments]    ${alias}    ${netcard_name}    ${timeout}=${60}
    [Documentation]    station 通过dhcp获取地址
    ...
    ...    参数
    ...    - timeout : 默认60s，执行dhclient获取地址的命令后，等待的时间
    ...
    ...    返回：(result,ip)
    ...    True：成功获取
    ...    False：未获取
    Sta.Write    ${alias}    dhclient -nw ${netcard_name}
    Sta.Read Until Prompt    ${alias}
    Sleep    ${timeout}
    ${ip}=    Sta.Sta Get Interface Ip    ${alias}    ${netcard_name}
    ${retFlag}=    Tools.Is None    ${ip}
    ${retFlag}=    Evaluate    not ${retFlag}
    [Return]    ${retFlag}    ${ip}

Check Sta Ping On Specific Int
    [Arguments]    ${alias}    ${ipaddress}    ${interface}    ${pingCount}=30
    [Documentation]    注意：关键字返回的是ping失败率，如失败率为70%，则返回数字70
    ${output}=    Sta.Execute Command    ${alias}    ping ${ipaddress} -I ${interface} -c ${pingCount}
    ${lossStr}=    Tools.Get Value From String    ${output}    (\\d+)% packet loss
    ${lossValue}=    Convert To Integer    ${lossStr}
    Log    ${output}
    [Return]    ${lossValue}
