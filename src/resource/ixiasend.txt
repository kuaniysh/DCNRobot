*** Settings ***
Documentation     控制ixia各类操作的关键字集合，用法规范：
...
...               ---
...               1. *连接ixia:*
...               - 在直接包含test case的test suite内通过关键字Connect To Ixia连接，一般放在setup内
...               - *注意: 在执行Connect To Ixia的test suite结束时，会将ixia的连接断开，因此需要在每个直接包含测试例的test suite内使用Connect To Ixia*
...               - 测试模块初始化的过程，如果需要控制Ixia，需要在初始化关键字的开始使用Connect To Ixia，在初始化关键字的结束时关闭Shutdown Proxy Server，一般初始化关键字在最高层test suite的setup中
...               - 测试模块清理配置的过程，如果需要控制Ixia，需要在清理配置的关键字的开始使用Connect To Ixia，在清理配置的关键字的结束时关闭Shutdown Proxy Server，一般清理配置的关键字在最高层test suite的teardown中
...
...               ---
...               2. *编辑报文:*
...               - 分层编辑报文，目前提供的关键字有：Build Ether; Build Dot1Q; Build Arp; Build Ip
...               - 对于4层以上的报文，一般采用关键字Build Payload来补充，或者编写相应的报文结构来识别
...               - 通过关键字Build Packet组装各层报文，*注意: 各层报文要按从从低到高顺序编辑*
...               - *注意:编辑ixia支持的各层报文时，如果要实现如地址递增等的功能，需要使用关键字Make Kwargs来实现*
...
...               举例:
...               | ${dict}= | Ixiasend.Make Kwargs | saRepeatCounter=increment | numSA=10 |
...               | ixiasend.Build Ether | dst=00:00:00:00:00:02 | src=00:00:00:00:00:01 | kwargs=${dict} |
...               | ixiasend.Build Dot1q | vlan=${10} | prio=${7} | typeid=0x9100 |
...               | ixiasend.Build Dot1q | vlan=${20} | prio=${5} |
...               | ixiasend.Build Ip | dst=10.1.1.1 | src=20.1.1.2 | tos=${0xE0} |
...               | ixiasend.Build Packet |
...
...               ---
...               3. *将编辑的报文设置到ixia端口:*
...               - 通过关键字Set Stream Packet By Api将编辑好的报文设置到ixia端口
...
...               ---
...               4. *设置流的属性:*
...               - 通过关键字Set Stream Control设置流的发送参数
...               - 通过上述过程，可依次设置ixia端口的所有流
...               - *注意: 在进行ixia端口设置前,需要Set Port Mode Default来恢复ixia端口的配置*
...
...               ---
...               5. *设置ixia端口的属性:*
...               - 目前支持的：速率双工 Set Port Speed Duplex; 流控 Set Port Flowcontrol
...               - *注意: ixia端口属性设置后，清除需要使用关键字Set Port Config Default*
...
...               ---
...               6. *发包:*
...               - 关键字: Start Transmit
...               - 如果不是持续发包，可以使用关键字Wait For Transmit Done来等待发送完成
...               ---
...               7. *停止发包:*
...               - 关键字: Stop Transmit
...
...               ---
...               8. *抓包过滤:*
...               - 抓包关键字: Start Capture
...               - 停止抓包关键字: Stop Capture
...               - 获取抓包的数量: Get Capture Packet Num
...               - 过滤报文: Filter Capture Packet,
...               - *注意: 过滤报文之前需要先Get Capture Packet,这样可以按不同条件，反复过滤报文; 同时提供关键字 Clear Capture Packet用于清除获取的抓包报文*
...
...               ---
...               9. *获取统计数据:*
...               - 关键字 Get Statics
...
...               ---
Library           ../lib/Ixia.py
Library           String
Library           Collections

*** Keywords ***
Build Packet
    [Arguments]    ${length}=${128}    ${packetstr}=${None}
    [Documentation]    将之前建立的各层字段组织为一个报文
    ...
    ...    参数：
    ...    - length \ \ \ \ : \ \ 报文长度，不足的由00补足
    ...    - packetstr : \ \ 默认为None，该参数被赋值后，组成的报文将由packetstr决定，而不是由之前建立的各层字段，packetstr是scapy包的命令字符串，一般情况下用不到
    ${rc}=    Ixia.Build Packet    ${length}    ${packetstr}
    [Return]    ${rc}

Build Ether
    [Arguments]    ${dst}=ff:ff:ff:ff:ff:ff    ${src}=00:00:00:00:00:00    ${typeid}=${None}    ${kwargs}=${None}
    [Documentation]    build Ethernet field packet
    ...
    ...    args:
    ...    - dst \ \ \ : Dest Mac \ \ \ = ff:ff:ff:ff:ff:ff
    ...    - src \ \ \ : Source Mac \ = 00:00:00:00:00:00
    ...    - typeid : type \ \ \ \ \ \ \ = None
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Ether | dst=00:00:00:00:00:01 | src=00:00:00:00:00:02 |
    ...    | Build Ether | src=00:00:00:00:00:02 |
    ...    | Build Ether | dst=00:00:00:00:00:02 |
    ${plen}=    Ixia.Build Ether    ${dst}    ${src}    ${typeid}    ${kwargs}
    [Return]    ${plen}

Build Arp
    [Arguments]    ${hwtype}=${0x1}    ${ptype}=${0x800}    ${hwlen}=${6}    ${plen}=${4}    ${op}=${1}    ${hwsrc}=00:00:00:00:00:00
    ...    ${psrc}=0.0.0.0    ${hwdst}=00:00:00:00:00:00    ${pdst}=0.0.0.0    ${kwargs}=${None}
    [Documentation]    build arp field packet
    ...
    ...    args:
    ...    - hwtype = 0x1
    ...    - ptype \ = 0x800
    ...    - hwlen \ = 6
    ...    - plen \ \ = 4
    ...    - op \ \ \ \ = 1
    ...    - hwsrc \ = 00:00:00:00:00:00
    ...    - psrc \ \ = 0.0.0.0
    ...    - hwdst \ = 00:00:00:00:00:00
    ...    - pdst \ \ = 0.0.0.0
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Arp | hwsrc=00:00:00:00:00:01 | psrc=10.1.1.1 | hwdst=10.1.1.254 |
    ...    | Build Arp | op=${2} | hwsrc=00:00:00:00:00:02 | psrc=10.1.1.254 | pdst=10.1.1.1 |
    ${packetlen}=    Ixia.Build Arp    ${hwtype}    ${ptype}    ${hwlen}    ${plen}    ${op}
    ...    ${hwsrc}    ${psrc}    ${hwdst}    ${pdst}    ${kwargs}
    [Return]    ${packetlen}

Build Ip
    [Arguments]    ${version}=${4}    ${ihl}=${None}    ${tos}=${0x0}    ${iplen}=${None}    ${iden}=${0}    ${flags}=${0}
    ...    ${frag}=${0}    ${ttl}=${64}    ${proto}=${None}    ${chksum}=${None}    ${src}=0.0.0.0    ${dst}=0.0.0.0
    ...    ${options}=${None}    ${kwargs}=${None}
    [Documentation]    build ip field packet
    ...
    ...    args:
    ...    - version = 4
    ...    - ihl \ \ \ \ = None
    ...    - tos \ \ \ \ = 0x0
    ...    - iplen \ \ = None
    ...    - iden \ \ \ = 0
    ...    - flags \ \ = 0
    ...    - frag \ \ \ = 0
    ...    - ttl \ \ \ \ = 64
    ...    - proto \ \ = None
    ...    - chksum \ = None
    ...    - src \ \ \ \ = 0.0.0.0
    ...    - dst \ \ \ \ = 0.0.0.0
    ...    - options = None \ #packets list
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Ip | src=10.1.1.1 | dst=10.1.1.254 |
    ${packetlen}=    Ixia.Build Ip    ${version}    ${ihl}    ${tos}    ${iplen}    ${iden}
    ...    ${flags}    ${frag}    ${ttl}    ${proto}    ${chksum}    ${src}
    ...    ${dst}    ${options}    ${kwargs}
    [Return]    ${packetlen}

Build Dot1Q
    [Arguments]    ${prio}=${0}    ${cfi}=${0}    ${vlan}=${1}    ${typeid}=${None}    ${kwargs}=${None}
    [Documentation]    build 802.1Q field packet
    ...
    ...    args:
    ...    - prio \ \ \ = 0
    ...    - cfi \ \ \ \ \ = 0
    ...    - vlan \ \ \ = 1
    ...    - typeid \ = None
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Dot1q | prio=${7} | vlan=${10} |
    ${packetlen}=    Ixia.Build Dot1q    ${prio}    ${cfi}    ${vlan}    ${typeid}    ${kwargs}
    [Return]    ${packetlen}

Build Payload
    [Arguments]    ${payload}
    [Documentation]    build payload field packet
    ...
    ...    args:
    ...    - payload \ = None; \ filled automatically using \x00; if you fill manually,please assinged using hexstring,and length para is invlaid
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Payload | 000102030405 |
    ${packetlen}=    Ixia.Build Payload    ${payload}
    [Return]    ${packetlen}

Connect To Ixia
    [Arguments]    ${address}    ${username}=${None}
    [Documentation]    start ixia proxy server and connect to ixia;
    ...
    ...    Note: in the beginning of \ every lowest test suit,please use this keyword,in the end of this test suit,the ixia proxy server will be shutdown automatically
    ...
    ...    args:
    ...    - address: the ip address of ixia
    ...    - uername: take ixia port ownership with username, it will take os hostname by default vaule None
    ...
    ...    return:
    ...    - True or False
    ${rc}=    Ixia.Init Ixia    ${address}    ${username}
    Should Be True    ${rc}
    [Return]    ${rc}

Start Transmit
    [Arguments]    ${chasId}    ${card}    ${port}
    [Documentation]    start to transmit stream
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Start Transmit    ${chasId}    ${card}    ${port}
    Should Be Equal As Integers    ${rc}    0
    [Return]    ${rc}

Stop Transmit
    [Arguments]    ${chasId}    ${card}    ${port}
    [Documentation]    stop to transmit stream
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Stop Transmit    ${chasId}    ${card}    ${port}
    Should Be Equal As Integers    ${rc}    0
    [Return]    ${rc}

Get Statics
    [Arguments]    ${chasId}    ${card}    ${port}    @{stats}
    [Documentation]    get port statics
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: ixia card
    ...    - port: ixia port
    ...    - stats: a string or a string list;
    ...    \ \ \ \ tx include:txpps,txBps,txbps,txpackets,txbytes,txbits;
    ...    \ \ \ \ rx include:rxpps,rxBps,rxbps,rxpackets,rxbytes,rxbits;
    ...    \ \ \ \ rxIpv4Packets,rxUdpPackets,rxTcpPackets;
    ...    \ \ \ \ other info:updown: 0:down,1:up;
    ...    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ txstate: 0:stop,1:start;
    ...    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lineSpeed: The speed configured for the port,unit:Mbps;
    ...    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ duplex: 0:half,1:full;
    ...    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ flowControlFrames : flow Control Frames Received
    ...    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ userStat1: user defined statistics 1
    ...    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ userStat2: user defined statistics 2
    ...    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ captureFilter: capture Filter statistics
    ...    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ captureTrigger: capture Trigger statistics
    ...
    ...    return:
    ...    - a statics number or a statics number list; statics number will be a non negative number:
    ...    - negative number: error code
    ...
    ...    example:
    ...    | Get Statics | 1 | 1 | 1 | txpps |
    ...    | Get Statics | 1 | 1 | 1 | txpps | rxpps |
    ${rc}=    Ixia.Get Statistics    ${chasId}    ${card}    ${port}    @{stats}
    [Return]    ${rc}

Clear Statics
    [Arguments]    ${chasId}    ${card}    ${port}
    [Documentation]    clear all statics of ixia port
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Clear Statics    ${chasId}    ${card}    ${port}
    [Return]    ${rc}

Set Stream Packet By Datapattern
    [Arguments]    ${chasId}    ${card}    ${port}    ${streamId}
    [Documentation]    set a packet on stream of ixia port,filled src/dst mac by ixia api, and other fields by ixia datapattern method
    ...
    ...    Note:please use this keyword after Build Packet
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - streamId: stream id
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Stream Packet By Datapattern    ${chasId}    ${card}    ${port}    ${streamId}
    Should Be Equal As Integers    ${rc}    0
    [Return]    ${rc}

Start Capture
    [Arguments]    ${chasId}    ${card}    ${port}
    [Documentation]    start to capture stream
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Start Capture    ${chasId}    ${card}    ${port}
    [Return]    ${rc}

Stop Capture
    [Arguments]    ${chasId}    ${card}    ${port}
    [Documentation]    stop to capture stream
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Stop Capture    ${chasId}    ${card}    ${port}
    [Return]    ${rc}

Get Capture Packet
    [Arguments]    ${chasId}    ${card}    ${port}    ${from}=${1}    ${to}=${1000}
    [Documentation]    get capture packet, and save internally
    ...
    ...    Note:please use this keyword after Start Capture and Stop Capture
    ...
    ...    args:
    ...    - chasId: \ \ \ \ \ \ \ normally should be 1
    ...    - card: \ \ \ \ \ \ \ \ \ ixia card
    ...    - port: \ \ \ \ \ \ \ \ \ ixia port
    ...    - packet_from: \ \ default 1
    ...    - packet_to: \ \ \ \ default 1000, and will be adjust by actual capture num
    ...
    ...    return:
    ...    - non negative number: num of capture packet
    ...    - negative number: error code
    ${rc}=    Ixia.Get Capture Packet    ${chasId}    ${card}    ${port}    ${from}    ${to}
    Should Be True    ${rc} >= 0
    [Return]    ${rc}

Get Capture Packet Num
    [Arguments]    ${chasId}    ${card}    ${port}
    [Documentation]    get capture packet num,please use this keyword after Start Capture and Stop Capture
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - timeout: default 180s
    ...
    ...    return:
    ...    - non negative number: num of capture packet
    ...    - negative number: error code
    ${rc}=    Ixia.Get Capture Packet Num    ${chasId}    ${card}    ${port}
    [Return]    ${rc}

Filter Capture Packet
    [Arguments]    ${chasId}    ${card}    ${port}    ${fliter}=${None}
    [Documentation]    filter the capture packet,and return a list including filter num and filter packets
    ...
    ...    Note:please use this keyword after Get Capture Packet
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - filter: filter expression, default None,not filter capture packets;to know detail information,please visit http://www.ferrisxu.com/WinPcap/html/index.html WinPcap用户指南--过滤串表达式的语法
    ...
    ...    return:
    ...    - (num of filter,packet of filter)
    ...
    ...    ---
    ...    过滤串表达式的语法：
    ...
    ...    注意：这篇文档取自tcpdump的指南。原始的版本 www.tcpdump.org 找到。
    ...
    ...    wpcap的过滤器是以已声明的谓词语法为基础的。过滤器是一个ASCII字符串，它包含了一个过滤表达式。pcap_compile()把这个表达式编译成内核级的包过滤器。
    ...    这个表达式会选择那些数据包将会被堆存。如果表达式没有给出，那么，网络上所有的包都会被内核过滤引擎所认可。不然，只有那些表达式为'true'的包才会被认可。
    ...
    ...    这个表达式包含了一个或多个原语。原语通常包含了id(名字或序列)，这些id优先于限定词。以下是三种不同的限定词：
    ...
    ...    输入(type)
    ...    指明了哪些东西是id所代表的。可能的输入是host，net和port。比如：`host foo'，`net 128.3'，`port 20'。如果没有输入限定词，就假定是host
    ...    方向(dir)
    ...    由id指明了一个特定的传输方向。可能的方向是src，dst，src or dst。比如，'src foo'，'dst net 128.3'，`src or dst port ftp-data'。如果没有指定，就假定是src or dst。如果没有链路层(比如，像slip这样的点对点协议)，那么限定词可以使用inbound和outbound，来指明一个方向。
    ...    协议(proto)
    ...    限定词限制了所匹配的协议。可能的协议有：ether，fddi，tr，ip，ip6，arp，rarp，decnet，tcp和udp。比如：`ether src foo'，`arp net 128.3'，`tcp port 21'。如果没有指定协议限定词，那么就假定所有的协议都会被允许。例如：'src foo'等价于'(ip or arp or rarp)src foo'(当然，不能有不符合语法的字母出现)，'net bar'等价于'(ip or arp or rarp) net bar'，'port53'等价于'(tcp or udp) port 53'。
    ...    [ 'fddi'通常是'ether'的别名；解析器会认为它们是在特定网络接口上的数据链路层。FDDI的首部包含了和以太网很相似的源地址和目的地址，并且通常也包含了和以太网很相似的数据包类型。所以，在FDDI网域上使用过滤器和在以太网上使用过滤器基本一致。FDDI的首部还包括了其他的数据，不过你不能在过滤器表达式内表示他们。
    ...
    ...    同样的，'tr'也是'ether'的一个别名，它是较早被应用于FDDI的首部，也应用在令牌环网络首部。]
    ...
    ...    除了以上内容，还有一些特殊的限定词和上面的形式不太一样，它们是：gateway，broadcast，less，greater和一些算术表达式。这些内容会在下面和大家介绍。
    ...
    ...    我们可以使用and，or和not将原语连接起来，来构造一个更复杂的过滤表达式。例如：`host foo and not port ftp and not port ftp-data'。如果要简化输入，我们可以把已列出的id限定词省略。比如：`tcp dst port ftp or ftp-data or domain' 和 `tcp dst port ftp or tcp dst port ftp-data or tcp dst port domain'是完全等价的。
    ...
    ...    可使用的原语有：
    ...
    ...    dst host host
    ...    当IPv4/v6数据包的目标域(destination field)为host时为true，host既可以是地址，也可以是名字。
    ...    src host host
    ...    当IPv4/v6数据包的源域(source field)为host时为true。
    ...    host host
    ...    当IPv4/v6数据包的源域(source field)或目标域(destination field)为host时为true。以上任何一个host表达式可以是ip，arp，rarp或ip6开头，如下所示：
    ...    ip host host
    ...    等价于：
    ...    ether proto \ip and host host
    ...    如果host是一个多IP地址，那么每一个地址都会被匹配。
    ...    ether dst ehost
    ...    当以太网的目的地址为ehost时为true。ehost可以是一个来自/etc/ether的名字，也可以是一个数字代号(参见 ethers(3N)for numeric format)。
    ...    ether src ehost
    ...    当以太网的源地址为ehost时为true。
    ...    ether host ehost
    ...    当以太网的目的地址，或源地址为ehost时为true。
    ...    gateway host
    ...    当host为网关时为true。即，以太网源地址或目的地址是host,但源地址和目的地址不同时为host。host必须能被机器的主机-IP地址(host-name-to-IP-address)机制找到(如主机名文件，DNS，NIS等)，也能被主机-以太网地址(host-name-to-Ethernet-address)机制找到(如/etc/ethers等)。例如：
    ...    ether host ehost and not host host
    ...    host / ehost均可使用名字或数字。这个语法目前在IPv6下不能工作。
    ...    dst net net
    ...    当IPv4/v6数据包的目的地址的网络号包含了net时为true。net可以是一个来自/etc/networks的名字，也可以是一个网络号(更多内容请参见 networks(4))。
    ...    src net net
    ...    当IPv4/v6数据包的源地址的网络号包含了net时为true。
    ...    net net
    ...    当IPv4/v6数据包的目的地址，或源地址的网络号包含了net时为true
    ...    net net mask netmask
    ...    当IP地址是 net ，子网掩码匹配 netmask 时为true。 可能需要 src 或 dst加以限制。 注意，这个语法不能应用于IPv6。
    ...    net net/len
    ...    当IP地址是 net ，子网掩码连续1的个数为 len 时为true。 可能需要 src 或 dst加以限制。
    ...    dst port port
    ...    当数据包是ip/tcp, ip/udp, ip6/tcp 或 ip6/udp，并且目的端口号是port时为true。port可以是数字，或是在/etc/services中被使用的名字。(参见 tcp(4P) and udp(4P))。如果使用名字，那么端口号和协议都将被检测。如果使用数字，或者一个不明确的名字，那么只有端口号会被检测。（比如：dst port 513将打印tcp/login数据流和udp/who数据流。port domain将打印tcp/domain的数据流和udp/domain的数据流）。
    ...    src port port
    ...    当源端口号是 port时为true。
    ...    port port
    ...    当源端口号或目的端口号为 port 时为true。以上任何一个port表达式可以以关键字tcp或udp开头，如下所示：
    ...    tcp src port port
    ...    只匹配源端口是 port 的tcp数据包。
    ...    less length
    ...    当数据包的长度小于等于length时为true。即：
    ...    len <= length.
    ...    greater length
    ...    当数据包的长度大于等于length时为true。即：
    ...    len >= length.
    ...    ip proto protocol
    ...    当数据包是IP数据包，并且它的协议类型为protocol时为true。protocol可以是一个数字，也可以是icmp, icmp6，igmp，igrp，pim，ah，esp，vrrp，udp 或 tcp中的一个。注意，tcp，udp， icmp是关键字，所以，它们要使用反斜杠(\)来转义，就好比C-shell中的\\。注意，这个原语不会去追踪协议首部链。
    ...    ip6 proto protocol
    ...    当数据包是IPv6数据包，并且它的协议类型为protocol时为true。注意，这个原语不会去追踪协议首部链。
    ...    ip6 protochain protocol
    ...    当数据包是IPv6数据包，并且，在它的协议首部链中，包含了protocol类型的协议首部时，为true。 例如：
    ...    ip6 protochain 6
    ...    能匹配所有的，拥有TCP协议首部的IPv6的数据包。在IPv6首部和TCP首部之间，可能包含认证首部，路由首部和跳数选项首部。由这个原语所生成的BPF(BSD Packet Filter，包过滤机制)码是复杂的，而且不能被BPF优化器优化，所以，在某些程度上，它的速度比较慢。
    ...    ip protochain protocol
    ...    功能和 ip6 protochain protocol相同，只是这个应用于 IPv4。
    ...    ether broadcast
    ...    当数据包是以太网广播数据包时为true。关键字ether是可选的。
    ...    ip broadcast
    ...    当数据包是IP广播数据包时为true。它会检查所有的广播，包括地址全是0的和地址全是1的，然后，检查子网掩码。
    ...    ether multicast
    ...    当数据包是以太网多播数据包时为true。关键字ether是可选的。 下面是一个常用短语`ether[0] & 1 != 0'
    ...    ip multicast
    ...    当数据包是IP多播数据包时为true。
    ...    ip6 multicast
    ...    当数据包是IPv6多播数据包时为true。
    ...    ether proto protocol
    ...    当数据包是以太类型的protocol时为true。protocol可以是一个数字，也可以是ip, ip6, arp, rarp, atalk, aarp,decnet, sca, lat, mopdl, moprc,iso, stp, ipx, netbeui中的一个。注意，这些符号也都是关键字，所以，他们都需要用反斜杠(\)转义。
    ...    [在使用FDDI(比如'fddi protocol arp')和令牌环(比如'tr protocol arp')和其他大多数这种协议时，协议根据802.2逻辑链路控制(LLC)来识别，这些信息通常在FDDI或令牌环首部的开始。
    ...    当需要识别大多数协议的标识，比如FDDI或令牌环时, Tcpdump只检查LLC报头的ID数据域，它们以SNAP格式存储，并且，组织单位识别码(Organizational Unit Identifier(OUI))为0x000000，以封装以太网。它不会检查这个包是不是SNAP格式的，并在0x000000单元有OUI。
    ...    然而，iso是个特例，它会检查LLC首部的目的服务存取点DSAP(Destination Service Access Point)和源服务存取点SSAP(Source Service Access Point)，stp和netbeui会检查LLC首部的DSAP，atalk会检查数据包是不是SNAP格式的，并且OUI是不是0x080007。Appletalk 同样如此。
    ...    在以太网的例子中，tcpdump检查大部分协议的以太网类型字段，iso，sap 和 netbeui除外，因为它们会检查802.3帧，然后检查LLC首部，就像它对FDDI和令牌环那样。atalk，它检查以太网帧的Appletalk etype和SNAP格式的以太网帧，arrp，它在以太网帧中检查Appletalk ARP etype，或是在OUI为0x000000的802.2 SNAP帧中查找，还有ipx，他会在以太网帧中检查IPX etype，在LLC首部检查IPX DSAP，没有用802.3封装的LLC首部的IPX，和SNAP帧中的IPX etype。]
    ...    decnet src host
    ...    当DECNET的源地址为host时为true，它可能是一个格式为'10.123'的地址，也可能是一个DECNET主机名。[DECNET主机名称只有在配置成可运行DECNET的Ultrix系统中才得到支持。]
    ...    decnet dst host
    ...    当DECNET的目的地址为host时为true。
    ...    decnet host host
    ...    当DECNET的源地址或目的地址为host时为true。
    ...    ip, ip6, arp, rarp, atalk, aarp, decnet, iso, stp, ipx, netbeui
    ...    缩写是：
    ...    ether proto p
    ...    p 是以上协议中的一个。
    ...    lat, moprc, mopdl
    ...    缩写是：
    ...    ether proto p
    ...    p 是以上协议中的一个。 注意： tcpdump 目前并不知道，如何解析出这些协议。
    ...    vlan [vlan_id]
    ...    当数据包是IEEE 802.1Q VLAN数据包时为true。若[vlan_id]被指定，则仅当数据包为指定的vlan_id，值才为true。注意，在假设数据包为VLAN数据包的前提下，表达式中的第一个关键字vlan会改变剩余表达式的解码偏移量。
    ...    tcp, udp, icmp
    ...    缩写是：
    ...    ip proto p or ip6 proto p
    ...    p 是以上协议中的一个。
    ...    iso proto protocol
    ...    当数据包的协议类型为protocol的OSI数据包时值为true。Protocol可以是一个数字或以下名称中的一个：clnp，esis或isis。
    ...    clnp, esis, isis
    ...    缩写是：
    ...    iso proto p
    ...    p 是以上协议中的一个。注意，tcpdump并不能完成这些协议的全部解析工作。
    ...    expr relop expr
    ...    若关系式如下：relop是 >, <, >=, <=, =, != 中的一个，并且expr是一个由正整常数（用标准C语言的语法表示），标准二进制运算符[ +, -, *, /, &, | ]，运算符的长度，和指定数据包存取，则值为true。要存取数据包内的数据，可以使用以下的语法：
    ...    proto [ expr : size ]
    ...    Proto 是 ether, fddi, tr, ip, arp, rarp, tcp, udp, icmp or ip6中的一个，它为索引操作指明了协议层。注意，tcp,udp和其他较高层的协议类型只能应用于IPv4，而不能用于IPv6(这个问题可能在将来能得到解决)。被指定的协议层的字节偏移量由expr给出。Size是可选的，它指明了数据域中，我们所感兴趣的字节数。它可以是1，2，或4，默认为1。运算符的长度，由关键字len给出，指明了数据包的长度。
    ...    例如，`ether[0] & 1 != 0'会捕捉所有的多播数据流。表达式`ip[0] & 0xf != 5'能捕捉所有带可选域的IP数据包。表达式`ip[6:2] & 0x1fff = 0'仅捕捉未分段的数据报和段偏移量是0的数据报。这个检查隐含在tcp和udp的下标操作中。例如，tcp[0]通常指第一个字节的TCP首部，而不是指第一个字节的分段。
    ...
    ...    有些偏移量和域值可以以名字来表示，而不是数值。以下协议首部域的偏移量是正确的：icmptype (ICMP 类型域), icmpcode (ICMP 代码域), and tcpflags (TCP 标志域)。
    ...
    ...    ICMP 类型域有以下这些： icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redirect, icmp-echo, icmp-routeradvert, icmp-routersolicit, icmp-timxceed, icmp-paramprob, icmp-tstamp, icmp-tstampreply, icmp-ireq, icmp-ireqreply, icmp-maskreq, icmp-maskreply.
    ...
    ...    TCP 标志域有以下这些： tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-push, tcp-ack, tcp-urg.
    ...
    ...    原语可以用以下内容组合：
    ...
    ...    用圆括号括起来的原语和操作符 (圆括号在Shell中是特殊符号，所以必须要转义)。
    ...    取反操作 (`!' 或 `not').
    ...    连接操作 (`&&' 或 `and').
    ...    选择操作 (`||' 或 `or').
    ...    取反操作的优先级最高。 连接操作和选择操作有相同的优先级，并且它们的结合方向为从左向右。 注意：做连接的时候是需要显示的 and 操作符的，而不是把要连接的东西写在一起。
    ...
    ...    如果给出一个标识符，却没有关键字，那么就会假定用最近使用的关键字。 例如：
    ...
    ...    not host vs and ace
    ...    等价于
    ...    not host vs and host ace
    ...    不能和下面的混淆
    ...    not ( host vs or ace )
    ...    表达式参数即可以作为单个参数，也可以作为多个参数传递给tcpdump，后者更加方便一些。一般的，如果表达式包含一个Shell的元字符，那么用一个参数传递比较容易，最好把它括起来，多个参数在传递前，用空格连接起来。
    @{filterres}=    Ixia.Filter Capture Packet    ${chasId}    ${card}    ${port}    ${fliter}
    Should Be True    @{filterres}[0] >= 0
    [Return]    @{filterres}

Set Stream Control
    [Arguments]    ${chasId}    ${card}    ${port}    ${streamId}    ${streamRate}    ${streamRateMode}
    ...    ${streamMode}    ${numPackets}=100    ${returnToId}=1
    [Documentation]    set stream trasmit mode
    ...
    ...    Note:please use this keyword after Set Stream Packet
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - streamId: stream id
    ...    - streamRate: stream send rate
    ...    - streamRateMode: 0:percent ; 1: pps ; 2: bps
    ...    - streamMode: stream control mode;
    ...    0: continuously transmit the frames on this stream;
    ...    1: stop transmission
    ...    2: advance
    ...    3: return to id ,default to stream 1
    ...    - numFrames: stream send packet num,enable when streamMode 1,2,3; default 100
    ...    - ReturnId: enable when streamMode 3 ,default 1
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Stream Control    ${chasId}    ${card}    ${port}    ${streamId}    ${streamRate}
    ...    ${streamRateMode}    ${streamMode}    ${numPackets}    ${returnToId}
    Should Be Equal As Integers    ${rc}    0
    [Return]    ${rc}

Wait For Transmit Done
    [Arguments]    ${chasId}    ${port}    ${card}    ${timeout}={180}
    [Documentation]    wait for transmiting \ done
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - timeout: default 180s
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Wait For Transmit Done    ${chasId}    ${port}    ${card}    ${timeout}
    [Return]    ${rc}

Set Port Mode Default
    [Arguments]    ${chasId}    ${port}    ${card}
    [Documentation]    set ixia port default,please use this keyword before Set Stream Packet
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Port Mode Default    ${chasId}    ${port}    ${card}
    [Return]    ${rc}

Clear Capture Packet
    [Arguments]    ${chasId}    ${port}    ${card}
    [Documentation]    clear saved capture packet
    ...
    ...    Note:Start Capture will clear saved capture packet automatically
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...
    ...    return:
    ...    - 0: ok
    ...    - negative number: error code
    ${rc}=    Ixia.Clear Capture Packet    ${chasId}    ${port}    ${card}
    [Return]    ${rc}

Shutdown Proxy Server
    [Documentation]    shutdown proxy sever
    ...
    ...    *Note: Do not use this keyword unless you know what you are doing*
    ...
    ...    args:
    ...
    ...    return:
    ...    - True or False
    ${rc}=    Ixia.Shutdown Proxy Server
    [Return]    ${rc}

Make Kwargs
    [Arguments]    @{kwargs}
    [Documentation]    构建各个报文字段的扩展参数，用法见举例，使用方法与IxExplorer一致
    ...
    ...    扩展参数表：
    ...
    ...    1. Build Ether：
    ...
    ...    1). daRepeatCounter：目的mac变化模式：0:递增；2：递减；5：随机
    ...
    ...    2). numDA：目的mac变化数量
    ...
    ...    3). daStep：目的mac变化的步长
    ...
    ...    4). saRepeatCounter：源mac变化模式：0:递增；2：递减；5：随机
    ...
    ...    5). numSA ：源mac变化数量
    ...
    ...    6). saStep：源mac变化的步长
    ...
    ...
    ...    举例：目的mac递增10个
    ...    | ${dict}= | Make Kwargs | daRepeatCounter=0 | numDA=10 |
    ...    | Build Ether | dst=00:00:01:00:00:01 | src=00:00:02:00:00:01 | kwargs=${dict} |
    ...    ---
    ...    2. Build Dot1Q：
    ...
    ...    1). mode：vlanID的变化模式：1：递增；2：递减
    ...
    ...    2). repeat：vlanID的变化数量
    ...
    ...    3). step：vlanID的变化步长
    ...
    ...    举例：vlan递增10个
    ...    | ${dict}= | Make Kwargs | mode=1 | repeat=10 |
    ...    | Build Dot1Q | prio=${7} | vlan=${10} | kwargs=${dict} |
    ...    ---
    ...
    ...    3. Build Arp:
    ...
    ...    1). destHardwareAddrMode: \ 目的mac地址变化模式：1：递增；2：递减
    ...
    ...    2). destHardwareAddrRepeatCount：目的mac地址变化数量
    ...
    ...    3). destProtocolAddrMode: \ \ 目的ip地址变化模式：1：递增；2：递减
    ...
    ...    4). destProtocolAddrRepeatCount: \ 目的ip地址变化数量
    ...
    ...    5). sourceHardwareAddrMode: \ 源mac地址变化模式：1：递增；2：递减
    ...
    ...    6). sourceHardwareAddrRepeatCount: \ 源mac地址变化数量
    ...
    ...    7). sourceProtocolAddrMode: \ \ 源ip地址变化模式：1：递增；2：递减
    ...
    ...    8). sourceProtocolAddrRepeatCount： 源ip地址变化数量
    ...    ---
    ...    4. Build Ip:
    ...
    ...    1). sourceIpMask: \ 源ip掩码：举例sourceIpMask=255.0.0.0
    ...
    ...    2). sourceIpAddrMode: 源ip变化模式：1：host递增；2：host递减；5：network递增；6：network递减
    ...
    ...    3). sourceIpAddrRepeatCount: \ 源ip变化数量
    ...
    ...    4). sourceClass: \ 源ip的类型：0：classA；1：classB；2：classC；3：classD；4：noClass
    ...
    ...    5). destIpMask: \ 目的ip掩码：举例destIpMask=255.0.0.0
    ...
    ...    6). destIpAddrMode: \ \ 目的ip变化模式：1：host递增；2：host递减；5：network递增；6：network递减
    ...
    ...    7). destIpAddrRepeatCount: 目的ip变化数量
    ...
    ...    8). destClass：目的ip的类型：0：classA；1：classB；2：classC；3：classD；4：noClass
    ...    ---
    ...    5. Build Icmp:
    ...
    ...    *note: not support*
    ...    ---
    ...    6. Build Igmpv1v2:
    ...
    ...    1). mode: \ group地址变化模式： 1：递增；2：递减；
    ...
    ...    2). repeatCount: \ group地址变化次数
    ...    ---
    ...    7. Build Ipv6:
    ...
    ...    1). sourceMask: \ 源ipv6掩码：举例sourceMask=96
    ...
    ...    2). sourceAddrMode: 源ipv6变化模式：5：ipV6IncrInterfaceId；6：ipV6DecrInterfaceId；7：ipV6IncrGlobalUnicastTopLevelAggrId；8：ipV6DecrGlobalUnicastTopLevelAggrId；9：ipV6IncrGlobalUnicastNextLevelAggrId；10：ipV6DecrGlobalUnicastNextLevelAggrId；11：ipV6IncrGlobalUnicastSiteLevelAggrId；12：ipV6DecrGlobalUnicastSiteLevelAggrId
    ...
    ...    3). sourceAddrRepeatCount: \ 源ipv6变化数量
    ...
    ...    4). sourceStepSize: \ 源ipv6地址每次变化的次数
    ...
    ...    5). destMask: \ 目的ipv6掩码：举例destMask=96
    ...
    ...    6). destAddrMode: \ \ 目的ipv6变化模式：5：ipV6IncrInterfaceId；6：ipV6DecrInterfaceId；7：ipV6IncrGlobalUnicastTopLevelAggrId；8：ipV6DecrGlobalUnicastTopLevelAggrId；9：ipV6IncrGlobalUnicastNextLevelAggrId；10：ipV6DecrGlobalUnicastNextLevelAggrId；11：ipV6IncrGlobalUnicastSiteLevelAggrId；12：ipV6DecrGlobalUnicastSiteLevelAggrId
    ...
    ...    7). destAddrRepeatCount: 目的ipv6变化数量
    ...
    ...    8). destStepSize：目的ipv6地址每次变化的次数
    ...
    ...    *Note:当设置destAddrMode时，destMask也必须同时设置，destMask的值与IxExplorer一致*
    ...    ---
    ...    8. Build Icmpv6 Mldv1 Query/Report/Done
    ...
    ...    1). AddrMask: \ 组播组地址掩码：默认128，必须是8的倍数
    ...
    ...    2). AddrMode: \ 组播组地址变化模式： 递增：uuuu，递减: dddd，默认是递增
    ...
    ...    3). AddrRepeatCount: \ 组播组地址变化次数，注意由于需要计算校验和，目前变化范围只能控制在1个字节以内，即变化后的地址范围在00-FF之间
    ...
    ...    4). StepSize: \ 组播组地址变化步长，默认为1
    @{kwlist}=    Create List    test    test
    : FOR    ${istr}    IN    @{kwargs}
    \    @{ilist}    String.Split String    ${istr}    =
    \    @{kwlist}=    Collections.Combine Lists    ${kwlist}    ${ilist}
    ${dict}=    Collections.Create Dictionary    @{kwlist}
    Log    ${dict}
    [Return]    ${dict}

Set Stream Packet By Api
    [Arguments]    ${chasId}    ${card}    ${port}    ${streamId}    ${fcs}=${0}
    [Documentation]    set a packet on stream of ixia port, filled all fields by ixia api
    ...
    ...    Note:please use this keyword after Build Packet
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: ixia card
    ...    - port: ixia port
    ...    - streamId: stream id
    ...    - fcs: stream crc
    ...    \ \ \ \ \ \ \ \ \ 0:streamErrorGood
    ...    \ \ \ \ \ \ \ \ \ 1:streamErrorAlignment
    ...    \ \ \ \ \ \ \ \ \ 2:streamErrorDribble
    ...    \ \ \ \ \ \ \ \ \ 3:streamErrorBadCRC
    ...    \ \ \ \ \ \ \ \ \ 4:streamErrorNoCRC
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Stream Packet By Api    ${chasId}    ${card}    ${port}    ${streamId}    ${fcs}
    Should Be Equal As Integers    ${rc}    0
    [Return]    ${rc}

Set Port Speed Duplex
    [Arguments]    ${chasId}    ${port}    ${card}    ${mode}    @{negChoice}
    [Documentation]    set port speed duplex
    ...
    ...    note: this keyword will cause the port updown and use set port config default to clear this config in the end of testcase
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - mode: \ \ 0: auto;
    ...    \ \ \ \ \ \ \ \ \ \ 1: force1gfull; *Note: force1gfull will not take effect on ixia*
    ...    \ \ \ \ \ \ \ \ \ \ 2: force100full;
    ...    \ \ \ \ \ \ \ \ \ \ 3: force100half;
    ...    \ \ \ \ \ \ \ \ \ \ 4: force10full;
    ...    \ \ \ \ \ \ \ \ \ \ 5: force10half;
    ...    \ \ \ \ \ \ \ \ \ \ 6: no autonegotiate, used for fiber port normally
    ...    \ \ \ \ \ \ \ \ \ \ -1: autonegotiate,but type of autonegotiate must be assigned by mulchoice
    ...    - negChoice: \ \ take effect when mode be -1,must be a list including below choice
    ...    \ \ \ \ \ \ \ \ \ \ 1: force1gfull;
    ...    \ \ \ \ \ \ \ \ \ \ 2: force100full;
    ...    \ \ \ \ \ \ \ \ \ \ 3: force100half;
    ...    \ \ \ \ \ \ \ \ \ \ 4: force10full;
    ...    \ \ \ \ \ \ \ \ \ \ 5: force10half;
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ...
    ...    example:
    ...    | Set Port Speed Duplex | 1 | 1 | 1 | 2 |
    ...    | Set Port Speed Duplex | 1 | 1 | 1 | -1 | 1 | 2 | 3 |
    ${rc}=    Ixia.Set Port Speed Duplex    ${chasId}    ${port}    ${card}    ${mode}    ${negChoice}
    [Return]    ${rc}

Set Port Flowcontrol
    [Arguments]    ${chasId}    ${port}    ${card}    ${flag}
    [Documentation]    set port flowcontrol
    ...
    ...    note: this keyword will cause the port updown and use set port config default to clear this config in the end of testcase
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - flag: \ \ 0: disable;
    ...    \ \ \ \ \ \ \ \ \ \ 1: enable;
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Port Flowcontrol    ${chasId}    ${port}    ${card}    ${flag}
    [Return]    ${rc}

Set Port Config Default
    [Arguments]    ${chasId}    ${port}    ${card}
    [Documentation]    set ixia port default,please use this keyword after set port flowcontrol or set port speed duplex to clear the config
    ...
    ...    note: this keyword will clear the stream config and cause the port updown
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Port Config Default    ${chasId}    ${port}    ${card}
    [Return]    ${rc}

Build Icmp
    [Arguments]    ${typeid}=${8}    ${code}=${0}    ${chksum}=${None}    ${iden}=${0}    ${seq}=${0}    ${kwargs}=${None}
    [Documentation]    build icmp field packet
    ...
    ...    *Note: this keyword do not support the parameter ${kwargs} now*
    ...
    ...    args:
    ...    - typeid = 8
    ...    - code \ \ \ \ = 0
    ...    - chksum \ \ \ \ = None
    ...    - iden \ \ = 0
    ...    - seq \ \ \ = 0
    ...    - kwargs \ \ \ \ = None
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Icmp | typeid=${0} |
    ${packetlen}=    Ixia.Build Icmp    ${typeid}    ${code}    ${chksum}    ${iden}    ${seq}
    ...    ${kwargs}
    [Return]    ${packetlen}

Build Igmpv1v2
    [Arguments]    ${version}=${0x11}    ${maxres}=${100}    ${chksum}=${None}    ${group}=0.0.0.0    ${kwargs}=${None}
    [Documentation]    build IGMPv1v2 field packet
    ...
    ...    args:
    ...    - version \ \ \ = 0x11
    ...    \ \ \ \ \ \ \ \ \ 0x11: query
    ...    \ \ \ \ \ \ \ \ \ 0x12: igmpv1 report
    ...    \ \ \ \ \ \ \ \ \ 0x16: igmpv2 report
    ...    \ \ \ \ \ \ \ \ \ 0x17: igmpv2 leave
    ...    - maxres \ \ \ \ = 100
    ...    - chksum \ \ \ \ = None
    ...    - group \ \ \ \ \ = 0.0.0.0
    ...    - kwargs \ \ \ \ = None,the detail spec in the doc of keywrod Make Kwargs
    ...
    ...    return:
    ...    -packet field length
    ...
    ...    exapmle:
    ...    | Build Igmpv1v2 | version=${0x16} | group=225.1.1.1 |
    ${packetlen}=    Ixia.Build Igmpv1v2    ${version}    ${maxres}    ${chksum}    ${group}    ${kwargs}
    [Return]    ${packetlen}

Set Port Ignorelink
    [Arguments]    ${chasId}    ${port}    ${card}    ${flag}
    [Documentation]    set port ignore link
    ...
    ...    note:
    ...    - this keyword normally should be used when send stream if port down;
    ...    - this keyword will cause the port updown and use set port config default to clear this config in the end of testcase
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - flag: \ \ 0: false; ignore link disable
    ...    \ \ \ \ \ \ \ \ \ \ 1: true; ignore link enable
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Port Ignorelink    ${chasId}    ${port}    ${card}    ${flag}
    [Return]    ${rc}

Build Ipv6
    [Arguments]    ${version}=${6}    ${tc}=${0}    ${fl}=${0}    ${plen}=${None}    ${nh}=${None}    ${hlim}=${64}
    ...    ${src}=::1    ${dst}=::1    ${kwargs}=${None}
    [Documentation]    build ipv6 field packet
    ...
    ...    args:
    ...    - version \ = 6
    ...    - tc \ \ \ \ \ \ \ \ = 0; \ \ \ \ \ \ \ \ traffic class
    ...    - fl \ \ \ \ \ \ \ \ \ = 0; \ \ \ \ \ \ \ \ flow label
    ...    - plen \ \ \ \ \ = None; \ \ payload length
    ...    - nh \ \ \ \ \ \ \ = None; \ \ \ next header,default 59
    ...    - hlim \ \ \ \ \ = 64; \ \ \ \ \ \ hop limit
    ...    - src \ \ \ \ \ \ \ = ::1
    ...    - dst \ \ \ \ \ \ \ = ::1
    ...    - kwargs \ \ \ \ = None,the detail spec in the doc of keywrod Make Kwargs
    ...
    ...    return:
    ...    - packet field length
    ...
    ...    exapmle:
    ...    | Build Ipv6 | src=2001::1 | dst=2002::1 |
    ${packetlen}=    Ixia.Build Ipv6    ${version}    ${tc}    ${fl}    ${plen}    ${nh}
    ...    ${hlim}    ${src}    ${dst}    ${kwargs}
    [Return]    ${packetlen}

Build Icmpv6 Mldv1 Query
    [Arguments]    ${code}=${0}    ${chksum}=${None}    ${mrd}=${10000}    ${reserved}=${0}    ${mladdr}=::    ${kwargs}=${None}
    [Documentation]    build mldv1 query field packet
    ...
    ...    args:
    ...    - code \ \ \ \ \ \ \ = 0
    ...    - chksum \ \ \ \ \ = None;
    ...    - mrd \ \ \ \ \ \ \ \ = 10000; \ \ \ \ \ max response delay
    ...    - reserved \ \ \ = 0;
    ...    - mladdr \ \ \ \ \ = ::
    ...    - kwargs \ \ \ \ = None,the detail spec in the doc of keywrod Make Kwargs
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Icmpv6 Mld Query |
    ${packetlen}=    Ixia.Build Icmpv6 Mldv1 Query    ${code}    ${chksum}    ${mrd}    ${reserved}    ${mladdr}
    ...    ${kwargs}
    [Return]    ${packetlen}

Build Icmpv6 Mldv1 Report
    [Arguments]    ${code}=${0}    ${chksum}=${None}    ${mrd}=${10000}    ${reserved}=${0}    ${mladdr}=::    ${kwargs}=${None}
    [Documentation]    build mldv1 query field packet
    ...
    ...    args:
    ...    - code \ \ \ \ \ \ \ = 0
    ...    - chksum \ \ \ \ \ = None;
    ...    - mrd \ \ \ \ \ \ \ \ = 0; \ \ \ \ \ max response delay
    ...    - reserved \ \ \ = 0;
    ...    - mladdr \ \ \ \ \ = ::
    ...    - kwargs \ \ \ \ = None,the detail spec in the doc of keywrod Make Kwargs
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Icmpv6 Mld Report | mladdr=ff3f::1 |
    ${packetlen}=    Ixia.Build Icmpv6 Mldv1 Report    ${code}    ${chksum}    ${mrd}    ${reserved}    ${mladdr}
    ...    ${kwargs}
    [Return]    ${packetlen}

Build Icmpv6 Mldv1 Done
    [Arguments]    ${code}=${0}    ${chksum}=${None}    ${mrd}=${10000}    ${reserved}=${0}    ${mladdr}=::    ${kwargs}=${None}
    [Documentation]    build mldv1 query field packet
    ...
    ...    args:
    ...    - code \ \ \ \ \ \ \ = 0
    ...    - chksum \ \ \ \ \ = None;
    ...    - mrd \ \ \ \ \ \ \ \ = 0; \ \ \ \ \ max response delay
    ...    - reserved \ \ \ = 0;
    ...    - mladdr \ \ \ \ \ = ::
    ...    - kwargs \ \ \ \ = None,the detail spec in the doc of keywrod Make Kwargs
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Icmpv6 Mld Done | mladdr=ff3f::1 |
    ${packetlen}=    Ixia.Build Icmpv6 Mldv1 Done    ${code}    ${chksum}    ${mrd}    ${reserved}    ${mladdr}
    ...    ${kwargs}
    [Return]    ${packetlen}

Build Icmpv6 Echo Request
    [Arguments]    ${code}=${0}    ${chksum}=${None}    ${identifier}=${0}    ${seq}=${0}    ${kwargs}=${None}
    [Documentation]    build icmpv6 echo request field packet
    ...
    ...    args:
    ...    - code \ \ \ \ \ \ \ = 0
    ...    - chksum \ \ \ \ \ = None;
    ...    - identifier \ \ = 0;
    ...    - seq \ \ \ \ \ \ = 0;
    ...    - kwargs \ \ \ \ = None, *not support*
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Icmpv6 Echo Request |
    ${packetlen}=    Ixia.Build Icmpv6 Echo Request    ${code}    ${chksum}    ${identifier}    ${seq}
    [Return]    ${packetlen}

Build Icmpv6 Echo Reply
    [Arguments]    ${code}=${0}    ${chksum}=${None}    ${identifier}=${0}    ${seq}=${0}    ${kwargs}=${None}
    [Documentation]    build icmpv6 echo reply field packet
    ...
    ...    args:
    ...    - code \ \ \ \ \ \ \ = 0
    ...    - chksum \ \ \ \ \ = None;
    ...    - identifier \ \ = 0;
    ...    - seq \ \ \ \ \ \ = 0;
    ...    - kwargs \ \ \ \ = None, *not support*
    ...
    ...    return:
    ...    packet field length
    ...
    ...    exapmle:
    ...    | Build Icmpv6 Echo Request |
    ${packetlen}=    Ixia.Build Icmpv6 Echo Reply    ${code}    ${chksum}    ${identifier}    ${seq}
    [Return]    ${packetlen}

Modify Capture Packet
    [Arguments]    ${packet}    ${offset}=${None}    ${value}=${None}
    [Documentation]    modify a capture packet using offset and hexstr
    ...
    ...    Note:please use this keyword after Filter Capture Packet
    ...
    ...    args:
    ...    - packet: \ \ \ the item in list of the sencond return value of Filter Capture Packet or the return value of itself to continue modify
    ...    - offset: \ \ \ offset of hexstr packet
    ...    - hexstr: \ \ \ a byte hex string using space to split, for exapmle: 'FF 00'
    ...
    ...    return:
    ...    - packet of scapy format
    ${ret_packet}=    Ixia.Modify Capture Packet    ${packet}    ${offset}    ${value}
    [Return]    ${ret_packet}

Set Stream Packet By Capture
    [Arguments]    ${chasId}    ${card}    ${port}    ${streamId}    ${packet}
    [Documentation]    set a capture packet on stream of ixia port
    ...
    ...    Note:please use this keyword after Modify Capture Packet or Filter Capture Packet
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - streamId: stream id
    ...    - packet: \ \ the return value of keyword Modify Capture Packet or the item in list of the sencond return value of Filter Capture Packet
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Stream Packet By Capture    ${chasId}    ${card}    ${port}    ${streamId}    ${packet}
    Should Be Equal As Integers    ${rc}    0
    [Return]    ${rc}

Get Statics Between Timeout
    [Arguments]    ${chasId}    ${card}    ${port}    ${stats}    ${timeout}
    [Documentation]    get port statics
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: ixia card
    ...    - port: ixia port
    ...    - stats: a string or a string list;
    ...    \ \ \ \ tx include:txpps,txBps,txbps,txpackets,txbytes,txbits
    ...    \ \ \ \ rx include:rxpps,rxBps,rxbps,rxpackets,rxbytes,rxbits
    ...    \ \ \ \ other info:updown: 0:down,1:up;
    ...    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ txstate: 0:stop,1:start;
    ...    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ lineSpeed: The speed configured for the port,unit:Mbps;
    ...    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ duplex: 0:half,1:full;
    ...    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ flowControlFrames : flow Control Frames Received
    ...    - timeout: \ \ unit: ms, note that timeout should less than 60s, if more than 60s,please use keyword Sleep of Buildtin in script
    ...
    ...    return:
    ...    - non negative number list including two item statics num, the first is before timeout item, the sencond is after timeout item
    ...    - negative number: error code
    ${rc}=    Ixia.Get Statistics Between Timeout    ${chasId}    ${card}    ${port}    ${stats}    ${timeout}
    [Return]    ${rc}

Set Port Filters Da
    [Arguments]    ${da1}=${None}    ${mask1}=${None}    ${da2}=${None}    ${mask2}=${None}
    [Documentation]    config DA1 and DA2 in ixia port filterPallette
    ...
    ...    args:
    ...    - da1: \ \ dst mac1 address,for example: 00 00 00 00 00 01
    ...    - mask1: dst mac1 address mask, for example: 00 00 00 00 00 00
    ...    - da2: \ \ dst mac2 address
    ...    - mask2: dst mac2 address mask
    ...
    ...    return:
    ...    - True : ok
    ${rc}=    Ixia.Set Port Filters Da    ${da1}    ${mask1}    ${da2}    ${mask2}
    [Return]    ${rc}

Set Port Filters Sa
    [Arguments]    ${sa1}=${None}    ${mask1}=${None}    ${sa2}=${None}    ${mask2}=${None}
    [Documentation]    config SA1 and SA2 in ixia port filterPallette
    ...
    ...    args:
    ...    - sa1: \ \ src mac1 address,for example: 00 00 00 00 00 01
    ...    - mask1: src mac1 address mask, for example: 00 00 00 00 00 00
    ...    - sa2: \ \ src mac2 address
    ...    - mask2: src mac2 address mask
    ...
    ...    return:
    ...    - True : ok
    ${rc}=    Ixia.Set Port Filters Sa    ${sa1}    ${mask1}    ${sa2}    ${mask2}
    [Return]    ${rc}

Set Port Filters Pattern Custom
    [Arguments]    ${offset1}=${None}    ${pattern1}=${None}    ${mask1}=${None}    ${offset2}=${None}    ${pattern2}=${None}    ${mask2}=${None}
    [Documentation]    config custom mode in ixia port filterPallette Pattern1 and Pattern2
    ...
    ...    args:
    ...    - offset1: \ \ offset in Pattern1, same to ixia config in IxExplorer
    ...    - pattern1: \ pattern in Pattern1, same to ixia config in IxExplorer
    ...    - mask1: \ \ \ \ mask in Pattern1, same to ixia config in IxExplorer
    ...    - offset2: \ \ offset in Pattern2, same to ixia config in IxExplorer
    ...    - pattern2: \ pattern in Pattern2, same to ixia config in IxExplorer
    ...    - mask2: \ \ \ \ mask in Pattern2, same to ixia config in IxExplorer
    ...
    ...    return:
    ...    - True : ok
    ${rc}=    Ixia.Set Port Filters Pattern Custom    ${offset1}    ${pattern1}    ${mask1}    ${offset2}    ${pattern2}
    ...    ${mask2}
    [Return]    ${rc}

Set Port Filters Uds1
    [Arguments]    ${da}=${None}    ${sa}=${None}    ${pattern}=${None}    ${errors}=${None}    ${size_min}=${None}    ${size_max}=${None}
    [Documentation]    config uds1 in ixia port filters
    ...
    ...    args:
    ...    - da: \ \ \ \ \ \ 0: any; 1: DA1; 2: Not DA1; 3: DA2; 4: Not DA2;
    ...    - sa: \ \ \ \ \ \ 0: any; 1: SA1; 2: Not SA1; 3: SA2; 4: Not SA2;
    ...    - pattern: \ 0: any; 1: pattern1; 2: not pattern1; 3: pattern2; 4: not pattern2; 5: pattern1 & pattern2;
    ...    - errors: \ \ 0: any; 1: good packet; 2: bad crc; 3: bad packet;
    ...    - size_min: minimum packet size
    ...    - size_max: maximum packet size
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Port Filters Uds1    ${da}    ${sa}    ${pattern}    ${errors}    ${size_min}
    ...    ${size_max}
    [Return]    ${rc}

Set Port Filters Uds2
    [Arguments]    ${da}=${None}    ${sa}=${None}    ${pattern}=${None}    ${errors}=${None}    ${size_min}=${None}    ${size_max}=${None}
    [Documentation]    config uds2 in ixia port filters
    ...
    ...    args:
    ...    - da: \ \ \ \ \ \ 0: any; 1: DA1; 2: Not DA1; 3: DA2; 4: Not DA2;
    ...    - sa: \ \ \ \ \ \ 0: any; 1: SA1; 2: Not SA1; 3: SA2; 4: Not SA2;
    ...    - pattern: \ 0: any; 1: pattern1; 2: not pattern1; 3: pattern2; 4: not pattern2; 5: pattern1 & pattern2;
    ...    - errors: \ \ 0: any; 1: good packet; 2: bad crc; 3: bad packet;
    ...    - size_min: minimum packet size
    ...    - size_max: maximum packet size
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Port Filters Uds2    ${da}    ${sa}    ${pattern}    ${errors}    ${size_min}
    ...    ${size_max}
    [Return]    ${rc}

Set Port Filters CaptureFilter
    [Arguments]    ${da}=${None}    ${sa}=${None}    ${pattern}=${None}    ${errors}=${None}    ${size_min}=${None}    ${size_max}=${None}
    [Documentation]    config capture filter in ixia port filters
    ...
    ...    args:
    ...    - da: \ \ \ \ \ \ 0: any; 1: DA1; 2: Not DA1; 3: DA2; 4: Not DA2;
    ...    - sa: \ \ \ \ \ \ 0: any; 1: SA1; 2: Not SA1; 3: SA2; 4: Not SA2;
    ...    - pattern: \ 0: any; 1: pattern1; 2: not pattern1; 3: pattern2; 4: not pattern2; 5: pattern1 & pattern2;
    ...    - errors: \ \ 0: any; 1: good packet; 2: bad crc; 3: bad packet;
    ...    - size_min: minimum packet size
    ...    - size_max: maximum packet size
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Port Filters Capfilter    ${da}    ${sa}    ${pattern}    ${errors}    ${size_min}
    ...    ${size_max}
    [Return]    ${rc}

Set Port Filters CaptureTrigger
    [Arguments]    ${da}=${None}    ${sa}=${None}    ${pattern}=${None}    ${errors}=${None}    ${size_min}=${None}    ${size_max}=${None}
    [Documentation]    config capture trigger in ixia port filters
    ...
    ...    args:
    ...    - da: \ \ \ \ \ \ 0: any; 1: DA1; 2: Not DA1; 3: DA2; 4: Not DA2;
    ...    - sa: \ \ \ \ \ \ 0: any; 1: SA1; 2: Not SA1; 3: SA2; 4: Not SA2;
    ...    - pattern: \ 0: any; 1: pattern1; 2: not pattern1; 3: pattern2; 4: not pattern2; 5: pattern1 & pattern2;
    ...    - errors: \ \ 0: any; 1: good packet; 2: bad crc; 3: bad packet;
    ...    - size_min: minimum packet size
    ...    - size_max: maximum packet size
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Port Filters Captrigger    ${da}    ${sa}    ${pattern}    ${errors}    ${size_min}
    ...    ${size_max}
    [Return]    ${rc}

Set Port Filters Enable
    [Arguments]    ${chasId}    ${card}    ${port}
    [Documentation]    enable ixia port filters \ *Note use keyword Set Port Config Default to clear the filter configuration*
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Port Filters Enable    ${chasId}    ${card}    ${port}
    Should Be Equal As Integers    ${rc}    0
    [Return]    ${rc}

Get Capture Packet Timestamp
    [Arguments]    ${chasId}    ${card}    ${port}    ${from}=${1}    ${to}=${1000}
    [Documentation]    get capture packet timestamp, and save internally
    ...
    ...    Note:please use this keyword after Start Capture and Stop Capture
    ...
    ...    args:
    ...    - chasId: \ \ \ \ \ \ \ normally should be 1
    ...    - card: \ \ \ \ \ \ \ \ \ ixia card
    ...    - port: \ \ \ \ \ \ \ \ \ ixia port
    ...    - packet_from: \ \ default 1
    ...    - packet_to: \ \ \ \ default 1000, and will be adjust by actual capture num
    ...
    ...    return:
    ...    - (non negative number,timestamp list): num of capture packet timestamp, timestamp list
    ...    - (negative number,[]): error code
    @{rc}=    Ixia.Get Capture Packet Timestamp    ${chasId}    ${card}    ${port}    ${from}    ${to}
    Should Be True    @{rc}[0] >= 0
    [Return]    @{rc}

Get Filter Capture Packet Timestamp
    [Arguments]    ${chasId}    ${card}    ${port}    ${fliter}=${None}
    [Documentation]    get timestamp of filter the capture packet, return a list including filter timestamp num and filter packets timestamp
    ...
    ...    Note:please use this keyword after Get Capture Packet and Get Capture Packet Timestamp
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - filter: filter expression, default None,not filter capture packets;to know detail information,please visit http://www.ferrisxu.com/WinPcap/html/index.html WinPcap用户指南--过滤串表达式的语法
    ...
    ...    return:
    ...    - (num of filter timestamp,packet timestamp of filter)
    ...
    ...    ---
    ...    过滤串表达式的语法见关键字Filter Capture Packet
    @{filterres}=    Ixia.Get Filter Capture Packet Timestamp    ${chasId}    ${card}    ${port}    ${fliter}
    Should Be True    @{filterres}[0] >= 0
    [Return]    @{filterres}

Create Portgroup Id
    [Arguments]    ${chasId}    ${groupId}
    [Documentation]    Creates a port group and assigns it the ID groupID. Specific errors are:
    ...    - The groupID port group already exists
    ...
    ...    args:
    ...    - chasId: \ \ \ \ normally should be 1
    ...    - groupID: \ \ \ port group id
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Create Portgroup Id    ${chasId}    ${groupId}
    [Return]    ${rc}

Destroy Portgroup Id
    [Arguments]    ${chasId}    ${groupId}
    [Documentation]    Destroys the port group with ID groupID. Specific errors are:
    ...    - The groupID port group already exists
    ...
    ...    args:
    ...    - chasId: \ \ \ \ normally should be 1
    ...    - groupID: \ \ \ port group id
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Destroy Portgroup Id    ${chasId}    ${groupId}
    [Return]    ${rc}

Add Port To Portgroup
    [Arguments]    ${chasId}    ${card}    ${port}    ${groupId}
    [Documentation]    Adds this port to a group with ID groupID. Specific errors are:
    ...    - No connection to a chassis
    ...    - The groupID port group does not exist
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - groupID: \ port group id
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Add Port To Portgroup    ${chasId}    ${card}    ${port}    ${groupId}
    [Return]    ${rc}

Del Port To Portgroup
    [Arguments]    ${chasId}    ${card}    ${port}    ${groupId}
    [Documentation]    Deletes this port from the group with ID groupID. Specific errors are:
    ...    - No connection to a chassis
    ...    - The groupID port group does not exist
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - groupID: \ port group id
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Del Port To Portgroup    ${chasId}    ${card}    ${port}    ${groupId}
    [Return]    ${rc}

Set Cmd To Portgroup
    [Arguments]    ${chasId}    ${groupId}    ${cmd}
    [Documentation]    Performs the action or command cmd specified on all ports in the group with groupID
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - groupID: \ port group id
    ...    - cmd: \ \ \ startTransmit;stopTransmit;startCapture;stopCapture
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Cmd To Portgroup    ${chasId}    ${groupId}    ${cmd}
    [Return]    ${rc}

Set Port Transmit Mode
    [Arguments]    ${chasId}    ${port}    ${card}    ${mode}
    [Documentation]    set port transmit mode
    ...
    ...    note: this keyword will cause the port updown and use set port config default to clear this config in the end of testcase
    ...
    ...    args:
    ...    - chasId: normally should be 1
    ...    - card: \ \ ixia card
    ...    - port: \ \ ixia port
    ...    - flag: \ \ 0: Packets Streams;
    ...    \ \ \ \ \ \ \ \ \ \ 4: AdvancedScheduler;
    ...    \ \ \ \ \ \ \ \ \ \ 7: Echo;
    ...
    ...    return:
    ...    - 0: ok
    ...    - non zero: error code
    ${rc}=    Ixia.Set Port Transmit Mode    ${chasId}    ${port}    ${card}    ${mode}
    [Return]    ${rc}
